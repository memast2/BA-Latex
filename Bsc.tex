\documentclass[abstracton,12pt]{scrreprt}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{matrix}
\usepackage{times}
\usepackage{listings}
\usepackage{amssymb}
\usepackage{amsfonts}
%\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{url}
\usepackage{chapterbib}
\usepackage{gensymb}
\usepackage{BTree}
\usepackage{weiwBTree}
\usepackage{float}
\usepackage{array}
\usetikzlibrary{shapes, calc}
\usepackage[ruled,linesnumbered,lined,commentsnumbered]{algorithm2e}

\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\setlength{\parindent}{0pt} 


\titlehead{Department of Informatics, University of Zürich}
\subject{\vspace*{2cm}BSc Thesis}
\title{Implementing an Index Structure for Streaming Time Series Data}
\author{
  Melina Mast\\[-5pt]
  \scriptsize Matrikelnummer: 13-762-588\\[-5pt]
  \scriptsize Email: \texttt{melina.mast@uzh.ch}
}
\date{\vspace*{2cm}August, 2016}
\publishers{
  \small supervised by Prof.\ Dr.\ Michael Böhlen and Kevin Wellenzohn \\[5cm]
  \begin{tikzpicture}[overlay]
    \node at (-3,-3) {\includegraphics[height=5.5cm]{IFIlogo}};
    \node at (7,-3) {\includegraphics[height=2cm]{dbtgBW}};
  \end{tikzpicture}
}

%----\dedication{dedicated to xxx}

% --------- 

\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

\newenvironment{proof}
  {\noindent{\bf Proof:\rm}}{\hfill$\Box$\vspace{\medskipamount}}

\def\bbbr{{\rm I\!R}}
\def\bbbm{{\rm I\!M}}
\def\bbbn{{\rm I\!N}}
\def\bbbz{{\rm I\!Z}}

% --------- 

\begin{document}


\maketitle

\chapter*{Acknowledgements}



\begin{abstract}
Many domains have applications that need to be fed continuously with the latest data. The financial stock market need to be fed with the latest exchange rates. This time series data is continuously extended, potentially even forever.\\
We propose a system that keeps a portion of time series data in main memory and which allow an efficient random and sorted access to the data in a time series. 
\end{abstract}

\chapter*{Zusammenfassung}

\tableofcontents
\listoffigures
\listoftables
\listofalgorithms
\renewcommand{\lstlistingname}{Algorithm}% Listing -> Algorithm


\addtocontents{loa}{\def\string\figurename{Algorithm}}

\chapter{Introduction}
A streaming time series $s$ is an unbounded sequence of data points that is continuously extended, potentially forever. Streaming time series are relevant to applications in diverse domains e.g. in finance, meteorology or sensor networks. Many domains have applications that need to be fed continuously with the latest data, like the financial stock market or the weather information. A system can only keep a limited size of data in main memory. Also the processing of large volumes of time series data is impractical.

The data kept in main memory needs to be limited to a portion of the streaming time series. In order to be practical for an application like the financial stock market, the data that arrives in a defined time interval (e.g. every 2 minutes) needs to be completely processed until the succeeding data arises.
The thesis presents a way to implement the described data structures after discussing the requirements. Furthermore, it documents the out coming experimental results.
In the end of the thesis, in Chapter \ref{sec:Summary}, the findings will be summarized and concluded.

\section{Thesis Outline}


\newtheorem{defn}{Definition}[section]
\newtheorem{exmp}{Example}[section]
\newcommand*{\argmin}{\operatornamewithlimits{argmin}\limits}

\chapter{Background}
\label{background}
A streaming time series is not always gapless. Due to sensor failures or transmission errors, values can get missing. To efficiently impute missing values, Wellenzohn et al.\cite{BScT} present the Top-$k$ Case Matching algorithm (TKCM). The algorithm is introduced in Section \ref{TKCM}.

\section{TKCM}
\label{TKCM}
TKCM defines a two-dimensional query pattern over the most recent values of a set of time series. 
The idea is to derive the missing value in a time series $s$ from the \emph{k} most similar past pattern. Therefore, it determines for each \emph{time series} $s$ a set of highly correlated \emph{reference time series} which exhibit similar behaviour to the base station e.g. similar weather situations. Hence, TKCM is able to calculate an estimation of a missing value in streaming time series data. 

\begin{defn}
	Measurement. A measurement consists of a value $v$ at a time point $t$.
\end{defn}
\begin{defn}
	Time window $W$. Let $W=[ \underline{t}, \bar{t} ]$ be a sliding window of length $|W|$. Time $\underline{t}$ stands for the oldest time point that fits into the time window and $\bar{t}$ stands for the current time point for which the stream produced a new value. 
\end{defn}
\begin{defn}
	Streaming Time Series. Let $S$ be a set $S = \{s_1,s_2,...\}$ of streaming time series. The value of time series $s \in S$ at time \emph{t} is denoted as $s(t)$. For base time series $s$, let $R_s = \langle r_1, r_2,...\rangle$ be an ordered sequence of the time series $r_i \in S \setminus \{s\}$. The set of $\text{reference time series}$ for $s$, $R_s^d$, at the current time $\bar{t}$ are the first $d$ time series in $R_s$ for which $r(\bar{t}) \neq \text{NIL}$.
	The time points in a streaming time series $s$ are in time window $W$. 
\end{defn}
\begin{defn}
	Pattern. Let $R_s^d=\{r_1,...,r_d\}$ be the ordered set of reference time series for a time series $s$. A $pattern$ $P(t)$ of length $l > 0$ over $R_s^d$ that is embedded at time $t$ is defined as a $d\times l$ matrix $P(t) = [p_{ij}]_{d\times l}$. 
\end{defn}
The two-dimensional query pattern $P(t)$ is anchored at a time point $t$ and consists of the subsequence of length $l$ spanning from $t-l+1$ to $t$ of each reference time series. Each row represents a subsequence of a reference time series and each column represents the values of the reference time series at a time point.\\Every reference time series has associated reference time series as well, to keep the own data complete.\\ 
Only the values in the streaming time series with time points in time window $W$ are kept in main memory. However, we assume that all the time points $t < \bar{t}$ have a time series \emph{s} that is complete. Hence, $\forall t < \bar{t} : s(t) \ne \text{NIL}$ since \emph{s} contains imputed values if the real ones were missing. \\
TKCM must not only recover and impute missing values, but also process the newest arriving values efficiently. In order to do that, TKCM must provide an insertion method for new arriving values to insert the new value into a streaming time series $s$. Since the time window has a limited, given size $|W|$, one value has to be deleted from the time series data for each new arriving value. Provided that, the time series data in window $W$ is already completely filled. \\       
Further, TKCM must be able to handle duplicate values. Assume the time window contains 100 temperature values from the same weather station and every 5 minutes a new value arrives. It is possible that the same temperature value arrives multiple times.



\section{Access Methods}
\label{AccessMethods}
TKCM uses two methods for accessing any time series $r \in S$, \emph{random} and \emph{sorted} access. \emph{Sorted} access is used for finding the most similar value to a given pattern cell and \emph{random} access finds the values to fill the rest of the pattern cells. The two methods are defined as follows: 
\begin{defn}
 	Random Access. Random access returns value r(t), given time series r and time point t.	
\end{defn}
\begin{defn}
	Sorted Access. Sorted access returns the next yet unseen time point $t_s \notin T$ such that the value $r(t_s)$ is most similar to a given pattern cell $P_{ij}$. $t(s)$ is defined as:
	\begin{align*}
	t_s = \argmin_{t_s \in W \setminus T} |r(t_s) - P_{ij}|
	\end{align*}
\end{defn}
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
	\definecolor{mycolor}{RGB}{224,224,224}
	\definecolor{mycolor2}{RGB}{192,192,192}
	\draw[step=1cm,color=black] (0,0) grid (3,2);
	\node at (0.5,+0.5) [label={[font=\tiny,label distance=0.3cm]below:$\text{14:10}$}, label={[font=\tiny,label distance=0.1cm]left:$\text{i=2}$}]{17.1};
	\node at (1.5,+0.5) [label={[font=\tiny,label distance=0.3cm]below:$\text{14:15}$}]{17.0};
	\node at (2.5,+0.5) [label=right:$r_2$,label={[font=\tiny,label distance=0.3cm]below:$\text{14:20}$}]{17.2};
	\node at (0.5,+1.5) [label={[font=\tiny,label distance=0.3cm]above:$\text{j=1}$}, label={[font=\tiny,label distance=0.1cm]left:$\text{i=1}$}]{16.1};
	\node at (1.5,+1.5) [label={[font=\tiny,label distance=0.3cm]above:$\text{j=2}$}]{16.3};
	\node at (2.5,+1.5) [label=right:$r_1$,label={[font=\tiny,label distance=0.25cm]above:$\text{j=3}$}]{16.5};	
\end{tikzpicture}
\caption{Query Pattern Q(t) of length $l=3$ and $d=2$ reference time series}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}
\definecolor{mycolor}{RGB}{224,224,224}
\definecolor{mycolor2}{RGB}{192,192,192}

\draw[->]  (-3.2,1) -- (-1,1) node [pos=0.5,above,font=\footnotesize] {sorted access};

\draw[step=1cm,color=black] (0,0) grid (3,2);
\node at (0.5,+0.5) [label={[font=\tiny,label distance=0.3cm]below:$\text{13:40}$}, label={[font=\tiny,label distance=0.1cm]left:$\text{i=2}$}]{x.xx};
\node at (1.5,+0.5) [label={[font=\tiny,label distance=0.3cm]below:$\text{13:45}$}]{x.xx};
\node at (2.5,+0.5) [label=right:$r_2$,label={[font=\tiny,label distance=0.3cm]below:$\text{13:50}$}]{x.xx};
\node at (0.5,+1.5) [label={[font=\tiny,label distance=0.3cm]above:$\text{j=1}$}, label={[font=\tiny,label distance=0.1cm]left:$\text{i=1}$}]{x.xx};
\node at (1.5,+1.5) [label={[font=\tiny,label distance=0.3cm]above:$\text{j=2}$}]{x.xx};
\node at (2.5,+1.5) [label=right:$r_1$,label={[font=\tiny,label distance=0.25cm]above:$\text{j=3}$}]{16.7};

\draw[->]  (3.8,1) -- (6.0,1) node [pos=0.5,above,font=\footnotesize] {random access};

\draw[step=1cm,color=black] (7,0) grid (10,2);
\node at (7.5,+0.5) [label={[font=\tiny,label distance=0.3cm]below:$\text{13:40}$}, label={[font=\tiny,label distance=0.1cm]left:$\text{i=2}$}]{16.1};
\node at (8.5,+0.5) [label={[font=\tiny,label distance=0.3cm]below:$\text{13:45}$}]{16.6};
\node at (9.5,+0.5) [label=right:$r_2$,label={[font=\tiny,label distance=0.3cm]below:$\text{13:50}$}]{17.1};
\node at (7.5,+1.5)[label={[font=\tiny,label distance=0.3cm]above:$\text{j=1}$}, label={[font=\tiny,label distance=0.1cm]left:$\text{i=1}$}]{15.6};
\node at (8.5,+1.5) [label={[font=\tiny,label distance=0.25cm]above:$\text{j=2}$}]{15.9};
\node at (9.5,+1.5) [label=right:$r_1$,label={[font=\tiny,label distance=0.25cm]above:$\text{j=3}$}] {16.7} ;


\end{tikzpicture}

\caption{Pattern for query pattern cell $q_{13}$}
\end{figure}


TKCM initializes a set $T =\{\}$. The set is filled during execution with all time points \emph{t} for which a pattern P(t) has been found. 
Using the sorted access mode, the algorithm finds the next yet unseen time point $t_s \notin T$ for which the value is most similar to a given value in a pattern cell $p_{ij}$. The time point $t_s \notin T$ is added to $T$. The time point $t_s$ has a corresponding pattern $P({t_s})$ which is at least for one pattern cell similar to the query pattern cell $p_{ij}$.\\
The random access mode is used to look up the values that pattern $P(t)$ is composed of. 

\chapter{Problem Definition}
The present thesis tries to introduce an efficient way to implement the $random$ and $\text{sorted access}$ methods described in Section \ref{AccessMethods} for a streaming time series $s$.

\section{Context}
We make the following assumptions for our system: 
\begin{itemize}  
	\item The values arrive in a fix interval. E.g. every five minutes. 
	\item There are no gaps between the arriving values. 
	\item There are no values arriving out-of-order. 
\end{itemize}


\section{Operations}
\label{sec:Op}
The system needs to efficiently perform on the streaming time series $s$ in a sliding window $W$: 
\begin{itemize}  
	\item shift$(\bar{t}, v)$: add value \emph{v} for the new current time point $\bar{t}$ and remove value \emph{v'} for the time point $\underline{t} - 1$ that just dropped out of time window $W$.
	\item lookup$(t)$: return the value of time series \emph{s} at time \emph{t}, denoted by $s(t)$.
	\item neighbor$(v, T)$: given a value \emph{v} and a set of time points $T$, return the time point $t \in T$ such that $|v-s(t)|$ is minimal.
	\item new\_neighborhood$(t,v,j,l)$: given a value \emph{v} for the time point $t$, the pattern length $l$ and the index $j$, return the new neighborhood $N$ at $t$.
\end{itemize}
Wellenzohn et al.\cite{BScT} suggest a combination of two data structures: a $B^+$tree and a circular array. The lookup operation can be performed by the circular array, while the neighbor operation takes advantage of the fact that the leaves of a $B^+$tree are sorted. \\Additional reasons for the data structures are described in Chapter \ref{sec:Approach}. Further, the implementation of the random and sorted access modes using the suggested data structures is presented and a solution for  handling duplicate values is proposed. 



\chapter{Approach}
\label{sec:Approach}
The lookup operation can be efficiently performed by the circular array, while the neighbor operation takes advantage of the fact that the leaves of a $B^+$tree are sorted. \\
Each time series $s \in S$ can be implemented as a circular array. The circular array is kept in main memory. It uses random access to look up value $s(t)$ for a given time $t$. Further, for each time series $s$ a $B^+$tree is maintained that is also kept in main memory. The $B^+$tree is ideal for sorted access by value and therefore for range queries. We have a circular array and a $B^+$tree for every time series $s$ we have new arriving measurements. E.g. for every sensor in a field that measures the weather temperature we update these two data structures. Both data structures are described in detail in Section \ref{sec:circularArray} and Section \ref{sec:BplusTree}.


\section{Circular Array}
\label{sec:circularArray}
A circular array is used to store the time series data, sorted by time. Further, the time interval is predefined e.g. every 3 minutes a new value arrives.\\ The value and time are directly stored in the circular array. The last update position is stored in a variable and updated with every insertion. The data structure consists of the following variables: 

\lstset{language=C}
\begin{lstlisting}
struct {
  timeStamp time;
  double value;
} Serie;
	
struct {
  Serie * data;
  int size;
  int lastUpdatePos;
  int count;
} Circular Array;
\end{lstlisting}
\BlankLine
The circular array $c$ has multiple variables: a counter, which counts the number of measurements in the array, a $lastUpdatePos$ to store the position that was last updated by a new arrived measurement, the size of the array which also represents the capacity for the number of measurements the array can hold and the data, which actually holds the time point and value of a measurement.

\subsection{Phases}
The circular array has two phases:
\begin{itemize}  
	\item First, the array is not full and is filled with every new arriving measurement until every position in the circular array is filled.  

			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[
				scale=0.7,
				every node/.style={outer sep=0pt, transform shape, font=\scriptsize},
				every matrix/.style={cells={scale=0.7}},
				]
				
				\definecolor{mycolor}{RGB}{224,224,224}
				
				% circular array
				\xyshift{-15mm}{-70mm}{
					\matrix [ampersand replacement=\&, outer sep=0pt, matrix anchor=north] (array) {
						\node[circularptr] (c1)  {2.2}; \&
						\node[circularptr] (c2)  {1.9}; \&
						\node[circularptr] (c3)  {1.5}; \&
						\node[circularptr] (c4)  {3.6}; \&
						\node[circularptr] (c5)  {6.2}; \&
						\node[circularptr, fill=mycolor] (c6)  {3.2}; \&
						\node[circularptr] (c7)  {}; \&
						\node[circularptr] (c8)  {}; \&
						\node[circularptr] (c9)  {}; \&
						\node[circularptr] (c10) {}; \&
						\node[circularptr] (c11) {}; \&
						\node[circularptr] (c12) {};  \\
						%
						\node[circularval] (left) {13:10}; \&
						\node[circularval] {13:15}; \&
						\node[circularval] {13:20}; \&
						\node[circularval] {13:25}; \&
						\node[circularval] {13:30}; \&
						\node[circularval, fill=mycolor] {13:35}; \&
						\node[circularval] {}; \&
						\node[circularval] {}; \&
						\node[circularval] {}; \&
						\node[circularval] {}; \&
						\node[circularval] {}; \&
						\node[circularval] (right){};\\
					};
				}
				% curly brace
				\draw [decorate,decoration={brace,mirror,amplitude=10pt}]
				([yshift=-5pt] left.south west) -- ([yshift=-5pt] right.south east)
				node [black,midway,yshift=-0.9cm] {\large size $|W|$};
				\end{tikzpicture}
				\vspace{2mm}
				\caption{Unfilled circular array of size $|W|$.}
				\label{fig:cat}
			\end{figure}
		
	\item After the circular array is full the number of measurements stays constant
	\begin{figure}[H]
		\centering
		\begin{tikzpicture}[
		scale=0.7,
		every node/.style={outer sep=0pt, transform shape, font=\scriptsize},
		every matrix/.style={cells={scale=0.7}},
		]
		
		\definecolor{mycolor}{RGB}{224,224,224}
		
		% circular array
		\xyshift{-15mm}{-70mm}{
			\matrix [ampersand replacement=\&, outer sep=0pt, matrix anchor=north] (array) {
				\node[circularptr] (c1)  {3.2}; \&
				\node[circularptr] (c2)  {1.3}; \&
				\node[circularptr] (c3)  {4.5}; \&
				\node[circularptr, fill=mycolor] (c4)  {4.6}; \&
				\node[circularptr] (c5)  {6.2}; \&
				\node[circularptr] (c6)  {3.2}; \&
				\node[circularptr] (c7)  {11.2}; \&
				\node[circularptr] (c8)  {55.3}; \&
				\node[circularptr] (c9)  {9.1}; \&
				\node[circularptr] (c10) {3.9}; \&
				\node[circularptr] (c11) {5.0}; \&
				\node[circularptr] (c12) {1.4};  \\
				%
				\node[circularval] (left) {14:10}; \&
				\node[circularval] {14:15}; \&
				\node[circularval] {14:20}; \&
				\node[circularval, fill=mycolor] {14:25}; \&
				\node[circularval] {13:30}; \&
				\node[circularval] {13:35}; \&
				\node[circularval] {13:40}; \&
				\node[circularval] {13:45}; \&
				\node[circularval] {13:50}; \&
				\node[circularval] {13:55}; \&
				\node[circularval] {14:00}; \&
				\node[circularval] (right){14:05};\\
			};
		}
		% curly brace
		\draw [decorate,decoration={brace,mirror,amplitude=10pt}]
		([yshift=-5pt] left.south west) -- ([yshift=-5pt] right.south east)
		node [black,midway,yshift=-0.9cm] {\large size $|W|$};
		\end{tikzpicture}
		\vspace{2mm}
		\caption{Filled circular array of size $|W|$.}
		\label{fig:cat}
	\end{figure}
\end{itemize}

\subsection{Observation}
The measurements in a circular array are stored in a defined interval without any gaps in between. Therefore the value position and insertion can be easily calculated.
\begin{example}
The value at time point $\text{14.25}$ is the newest measurement. Hence, the last update position is at time point $\text{14.25}$. A new measurement will be inserted at the next position in the circular array. So at the position of the oldest time point $\text{13:30}$\\
In order to lookup the value at time point $\text{14:00}$ we can take advantage of the fixed interval. If the last update position is at time point $\text{14.25}$, we can directly calculate the position for time point $\text{14:00}$, using the last update position and the fixed interval.
\end{example} 
The detailed insertion of a new measurement is presented in Algorithm \ref{alg:UpdateCA} and the lookup of a value at time point $t$ is presented in Algorithm \ref{alg:Lookup}.


\newpage
\section{$B^+$tree}
\label{sec:BplusTree}
A $B^+$tree is able to execute range queries very efficiently, since the leaves of a $B^+$tree are ordered and linked. To perform the \emph{neighbor}$(v,T)$ operation described in Section \ref{sec:Op}, the $B^+$tree we use has leaves linked in both directions. The Section \ref{structureBtree} presents the structure of the $B^+$tree we used for our implementation.

\subsection{The Structure of the used $B^+$tree}
\label{structureBtree}
The used $B^+$tree and the implementation is based on the book of Silberschatz et al.\cite{DatabaseSystemC}. We introduce the most important properties of a $B^+$tree, for further information please refer to the book.\\
The difference between the traditional $B^+$tree and the $B^+$tree we use is on the one hand, that the leaves are linked to the succeeding as well as the preceding leaf to efficiently perform the \emph{neighbor}$(v,T)$ operation and on the other hand, that our $B^+$tree is able to handle duplicate values. How our tree handles duplicate values is described in Section \ref{sec:allowDV}. The other properties of our $B^+$tree are presented in the following:\\
There are three types of nodes that may exist in a $B^+$tree: the root, interior nodes and leave nodes. The parameter \emph{n} determines the number of searchkeys and pointers in a node.

\paragraph{Leaf}
A leaf node must have at least $\ceil{(n-1)/2}$ keys and may hold at most $n-1$ keys.
\paragraph{Interior Node}
The interior nodes can have at most \emph{n-1} searchkeys and \emph{n} pointers, pointing to its child nodes. The structure of nonleaf nodes like interior nodes and the root, is the same as for leaf nodes. Except for the pointers which points to tree nodes. An interior node must have at least $\ceil{n/2}$ pointers. Hence, it must have at least of $\ceil{n/2}-1$ keys and can hold at most $n$ pointers.
\paragraph{Root}The root node is the only node that can contain less than $\ceil{n/2}$ pointers. The root node must have at least one searchkey and two pointers to child nodes, unless the root is a leaf node and hence has no children.
\begin{example}
	If $n$ is set to 7, an internal node may have between 4 and 7 children and therefore between 3 and 6 keys. The root may have between 2 and 7 children or if it is the only node in the tree it can have no children and just 1 key. A leaf node must have at least 3 keys and can have maximum 6 keys.
\end{example}

A node contains the following attributes: 
\lstset{language=C}
\begin{lstlisting}
struct {
  struct Node *parent;
  void ** pointers;
  int numOfKeys;
  double * keys;
  bool isLeaf;
  struct Node *prev, *next;
} Node;
\end{lstlisting}
\BlankLine
The node structure can be used for every type of node, since the structure of the root, the inner nodes and the leaf nodes is similar. A $B+$tree is built out of multiple nodes that include: A pointer to the parent, which is \emph{NIL} if there is no parent, pointers to the child nodes or in leaves pointer to measurement time points, the number of keys that a node holds at the moment, the actual keys, a boolean which is true if the node is a leaf node and a node also has two pointers to the previous and the next node. These two pointers are only used if the node is a leaf node. 


All paths from the root to a leaf have the same length. This significances that the tree is always \emph{balanced}.\\
The keys in an inner node and in a leaf node are always sorted from left to right. A node contains $m$ non-null pointers $\left(m \leq n\right)$. For $i = 2, 3, . . . ,m-1$, pointer $P_i$ points to the subtree that contains searchkey values less than $K_i$ and greater than or equal to $K_{i-1}$. Pointer $P_m$ points to the part of the subtree that contains those key values greater than or equal to $K_{m-1}$. 
\begin{figure}[ht!]
	\centering
	\begin{tikzpicture}[
	scale=0.7,
	every node/.style={outer sep=0pt, transform shape, font=\scriptsize},
	every matrix/.style={cells={scale=0.7}},
	]
	% root node
	\xyshift{-20mm}{0mm}{\btreeinodethree{root}{17.2}{}{}};
	
	%
	% intermediate nodes
	\xyshift{-50mm}{-15mm}{\btreelnodethree{n1}{7.5}{16.4}{}{}}
	\xyshift{ 10mm}{-15mm}{\btreelnodethree{n2}{17.2}{33.1}{43.5}}
	%
	% connecting root to leaf level nodes
	\foreach \x in {1,2} { \btreelink{root-\x}{n\x} }
	%
	% leaf pointers
	\draw[btlink] ([yshift=+3pt] n1-c.east) -- ([yshift=+3pt] n2-a.west);
	\draw[btlink] ([yshift=-3pt] n2-a.west) -- ([yshift=-3pt] n1-c.east);
	%
	\end{tikzpicture}
	\vspace{2mm}
	\caption{Left children keys < 17.2 and right children keys $\geq$ 17.2}
	\label{fig:BTreeBook}
\end{figure} 


\begin{figure}[htbp]
	\centering
	\begin{tikzpicture}[
	scale=0.7,
	every node/.style={outer sep=0pt, transform shape, font=\scriptsize},
	every matrix/.style={cells={scale=0.7}},
	]
	% root node
	\xyshift{-20mm}{0mm}{\btreeinodethree{root}{17}{}{}};
	
	%
	% intermediate nodes
	\xyshift{-50mm}{-15mm}{\btreeinodethree{n1}{7}{}{}{}}
	\xyshift{ 10mm}{-15mm}{\btreeinodethree{n2}{23}{37}{43}}
	%
	% connecting root to intermediate level nodes
	\foreach \x in {1,2} { \btreelink{root-\x}{n\x} }
	%
	% leaf nodes
	\xyshift{-90mm}{-30mm}{\btreelnodethree{n11}{2.5}{3}{6.1}}
	\xyshift{-60mm}{-30mm}{\btreelnodethree{n12}{7}{13.2}{}}
	\xyshift{-30mm}{-30mm}{\btreelnodethree{n21}{17}{18.1}{}}
	\xyshift{ 0mm}{-30mm}{\btreelnodethree{n22}{23}{25.4}{}}
	\xyshift{ 30mm}{-30mm}{\btreelnodethree{n23}{37}{38.9}{40}}
	\xyshift{ 60mm}{-30mm}{\btreelnodethree{n24}{43}{47.1}{}}
	%
	% connecting intermediate level to leaf nodes
	\foreach \x in {1,2}     { \btreelink{n1-\x}{n1\x} }
	\foreach \x in {1,2,3,4} { \btreelink{n2-\x}{n2\x} }
	%
	% leaf pointers
	\draw[btlink] ([yshift=+3pt] n11-c.east) -- ([yshift=+3pt] n12-a.west);
	\draw[btlink] ([yshift=-3pt] n12-a.west) -- ([yshift=-3pt] n11-c.east);
	\draw[btlink] ([yshift=+3pt] n12-c.east) -- ([yshift=+3pt] n21-a.west);
	\draw[btlink] ([yshift=-3pt] n21-a.west) -- ([yshift=-3pt] n12-c.east);
	\draw[btlink] ([yshift=+3pt] n21-c.east) -- ([yshift=+3pt] n22-a.west);
	\draw[btlink] ([yshift=-3pt] n22-a.west) -- ([yshift=-3pt] n21-c.east);
	\draw[btlink] ([yshift=+3pt] n22-c.east) -- ([yshift=+3pt] n23-a.west);
	\draw[btlink] ([yshift=-3pt] n23-a.west) -- ([yshift=-3pt] n22-c.east);
	\draw[btlink] ([yshift=+3pt] n23-c.east) -- ([yshift=+3pt] n24-a.west);
	\draw[btlink] ([yshift=-3pt] n24-a.west) -- ([yshift=-3pt] n23-c.east);
	%
	
	\foreach \x in
	{n11-1, n11-2, n11-3,n12-1, n12-2,n21-1,n21-2,n22-1, n22-2, n23-1, n23-2, n23-3, n24-1,n24-2}
	{ \path[<-] ([yshift=-15pt] \x.center) edge ([yshift=2pt] \x.center); }
	%
	
	
	\end{tikzpicture}
	\vspace{2mm}
	\caption{Example of a complete $B^+$tree}
	\label{fig:BTreeBook}
\end{figure}



\subsection{Application to our System}
The $B^+$tree described above contains searchkeys. In our case these searchkeys are the measurement values in our circular array. A value in time series $s$ can occur multiple times because the values are not unique. But for an efficient traversal of the tree the searchkeys should be comparable to each other. But, since the values are used as searchkeys, the $B^+$tree must be able to handle possible duplicates. Besides, the $B^+$tree needs to store the time point of a measurement because the time point is the amendment to the value of a measurement that makes it uniquely identifiable. Also the time point  is returned by the neighbor$(v,T)$ operation which is executed on the $B^+$tree. Section \ref{sec:allowDV} proposes an approach that allow to use duplicate values in a $B^+$tree and it explains how the time points of the measurements are stored. 

\subsection{Observation}
The next higher value $hv$ of a given value $v$ in a $B^+$tree is at the same time the right neighbor of $v$ and the next lower value $lv$ is also the left neighbor of $v$, since the leaves and their keys are sorted from left to right.
\begin{example}
	Assume we want to know the most similar value to the key $40$ in the $B^+$tree illustrated in Figure \ref{fig:BTreeBook}. We just have to compare $40$ to two values, namely the right neighbor $43$ and the left neighbor $38.9$. Hence, we find out that $38.9$ is the most similar value in the entire $B^+$tree. 
\end{example}
Another property of the $B^+$tree we can take advantage is that the path from the root to a leaf node has always the same length, thus, the number of nodes to traverse to find a specific value in a leaf is always the same. Therefore, searching a value takes always the same number of node traversals. This leads to a more constant computation time. 


\section{Handling Duplicate Values}
\label{sec:allowDV}
This Section presents a solution and its advantages to allow duplicate values in a $B^+$tree for our purposes.

\subsection{Associated doubly, circular Linked List}
\label{doublyLinked}
The idea of this method is to associate a doubly, circular linked list to the each key in a leaf node. Cormen et al.\cite{LinkedListBook} define linked lists as follows: 
\begin{definition}
	Linked List. A linked list is a data structure arranged in a linear order. The order is determined by a pointer in each object. It can either be sorted in the linear order of the keys stored in elements or it can be unsorted. Given an element $e$ in the list, $e.next$ points to the successor in the linked list $L$. The first element, or head, of the list has no predecessor and the last element, or tail, has no predecessor. A linked list may be either singly linked or doubly linked. A doubly linked list has an additional pointer in an element $e$ which points to the predecessor, namely $e.prev$.\\
	Each element of a doubly, linked list $L$ is an object with an attribute $key$ and two pointer attributes: $next$ and $prev$. In a circular list the $prev$ pointer of the head of the list points to the tail and the $next$ pointer ot the tail points to the $head$. If the element $e$ is the only element in the doubly, linked list the pointers $next$ and $prev$ point to $e$ itself. 
\end{definition}


We use a doubly, circular linked list for our system, where time points are stored as the key of a list element. Every searchkey in a leaf node of our $B^+$tree has an associated linked list. If a measurement value occurs multiple times in the time series $s$, the time points of the measurements are simply added to the linked list associated to the searchkey representing the value of the measurement. So instead of inserting the key again and using another position in the leaf, the new time point is inserted as a linked list value.\\ 
Associating a doubly, circular linked list that is interconnected in both directions is ideal for satisfying our requirements. The oldest value in a list, so the lowest time point, always is the element connected by a pointer from the leaf key to the list. Even though the doubly, circular linked list not really has an end and a beginning, we name the time point associated to the leaf the $head$ and we call the heads predecessor the $tail$. \\The Figure \ref{fig:DoublyLinked} illustrates the leaf level of a $B^+$tree and the associated linked lists. It shows that the oldest time point, here $\text{14:15}$, is connected to the tree and the newest time point, $\text{14:50}$, the tail, is at the previous position. Also, the Figure illustrates that a single value in a doubly, circular linked list is linked to itself. The upper level of the $B^+$tree and the rest of the linked lists are left away for clarity. 


\begin{figure}[H]
	\centering
	\begin{tikzpicture}[
	scale=0.7,
	every node/.style={outer sep=0pt, transform shape, font=\scriptsize},
	every matrix/.style={cells={scale=0.7}},
	]
	
	% leaf pointers
	\draw[btlink] ([yshift=+3pt] n11-c.east) -- ([yshift=+3pt] n12-a.west);
	\draw[btlink] ([yshift=-3pt] n12-a.west) -- ([yshift=-3pt] n11-c.east);
	\draw[btlink] ([yshift=+3pt] n12-c.east) -- ([yshift=+3pt] n21-a.west);
	\draw[btlink] ([yshift=-3pt] n21-a.west) -- ([yshift=-3pt] n12-c.east);
	\draw[btlink] ([yshift=+3pt] n21-c.east) -- ([yshift=+3pt] n22-a.west);
	\draw[btlink] ([yshift=-3pt] n22-a.west) -- ([yshift=-3pt] n21-c.east);
	\draw[btlink] ([yshift=+3pt] n22-c.east) -- ([yshift=+3pt] n23-a.west);
	\draw[btlink] ([yshift=-3pt] n23-a.west) -- ([yshift=-3pt] n22-c.east);
	\draw[btlink] ([yshift=+3pt] n23-c.east) -- ([yshift=+3pt] n24-a.west);
	\draw[btlink] ([yshift=-3pt] n24-a.west) -- ([yshift=-3pt] n23-c.east);
	%
	% leaf nodes
	\xyshift{-90mm}{-30mm}{\btreelnodethree{n11}{17.2}{}{}}
	\xyshift{-60mm}{-30mm}{\btreelnodethree{n12}{17.3}{18.2}{18.3}}
	\xyshift{-30mm}{-30mm}{\btreelnodethree{n21}{18.6}{18.8}{}}
	\xyshift{ 0mm}{-30mm}{\btreelnodethree{n22}{19.2}{19.3}{}}
	\xyshift{ 30mm}{-30mm}{\btreelnodethree{n23}{19.4}{}{}}
	\xyshift{ 60mm}{-30mm}{\btreelnodethree{n24}{19.7}{19.7}{19.8}}
	%
	
	% circular array
	\xyshift{-40mm}{-70mm}{
		\matrix [ampersand replacement=\&, outer sep=0pt, matrix anchor=north] (array) {
			\node[circularptr] (c1)  {}; \\	
			%
			\node[circularval] (left)(right) {14:15}; \\
		};
	}
	% circular array
	\xyshift{-10mm}{-70mm}{
		\matrix [ampersand replacement=\&, outer sep=0pt, matrix anchor=north] (array) {
			\node[circularptr] (c2)  {}; \\	
			%
			\node[circularval] (left)(right) {14:30}; \\
		};
	}	
	
	% circular array
	\xyshift{20mm}{-70mm}{
		\matrix [ampersand replacement=\&, outer sep=0pt, matrix anchor=north] (array) {
			\node[circularptr] (c3)  {}; \\	
			%
			\node[circularval] (left)(right) {14:50}; \\
		};
	}	
	
	
		% circular array
		\xyshift{-90mm}{-70mm}{
			\matrix [ampersand replacement=\&, outer sep=0pt, matrix anchor=north] (array) {
				\node[circularptr] (c5)  {}; \\	
				%
				\node[circularval] (left)(right) {13:50}; \\
			};
		}
		
		
	% draw pointers between circular array and B+ tree
	\path[btlink2] ([yshift=-2pt] c5.center)  edge[out=90,in=270] ([yshift=2pt] n11-1.center);	
	%circular links
	\path[btlink] ([yshift=-16pt] c5.west)  edge[out=-1500,in=-60] ([yshift=-16pt] c5.east);
	\path[btlink2] ([yshift=-24pt] c5.west)  edge[out=-1500,in=-60] ([yshift=-24pt] c5.east);

	
	
	\foreach \x in
	{n12-1, n12-2, n12-3,n21-1,n21-2,n22-1, n23-1, n24-1,n24-2, n24-3}
	{ \path[<-] ([yshift=-15pt] \x.center) edge ([yshift=2pt] \x.center); }
	%
	
	
	% draw pointers between circular array and B+ tree
	\path[btlink2] ([yshift=-2pt] c1.center)  edge[out=90,in=270] ([yshift=2pt] n22-2.center);
	% draw pointers for linked list
	\draw[btlink] ([yshift=-10pt] c1.east) -- ([yshift=-10pt] c2.west);
	\draw[btlink] ([yshift=-10pt] c2.east) -- ([yshift=-10pt] c3.west);
	\draw[btlink] ([yshift=-20pt] c2.west) -- ([yshift=-20pt] c1.east);
	\draw[btlink] ([yshift=-20pt] c3.west) -- ([yshift=-20pt] c2.east);
	%circular links
	\path[btlink] ([yshift=-10pt] c1.west)  edge[out=220,in=250] ([yshift=-10pt] c3.east);
	\path[btlink2] ([yshift=-20pt] c1.west)  edge[out=220,in=250] ([yshift=-20pt] c3.east);
	\end{tikzpicture}
	\vspace{2mm}
	\caption{Doubly, circular linked list associated to a leaf node}
	\label{fig:DoublyLinked}
\end{figure}

As described above, the leaf nodes in our $B^+$tree also have pointers, namely pointers to the associated linked list. But the number of pointers in leaf nodes is always equal to the number of searchkeys in the leaf. A pointer at position $i$ points to the doubly, linked list associated with the leaf key at position $i$.\\

\lstset{language=C}
\begin{lstlisting}
struct {
  timeStamp timestamp;
  struct ListValue *prev, *next;
} ListValue;
\end{lstlisting}
\BlankLine

A linked list element consist of the time point and the pointers to the predecessor $prev$ and to the successor $next$.\\
The insertion and the deletion of a list value from a linked list which contains multiple values is illustrated in Algorithm \ref{AddToList} and Algorithm \ref{deleteListValue}, respectively.\\


\begin{algorithm}[H]
	\IncMargin{1em}
	\SetAlgoLined
	\DontPrintSemicolon
	\KwData{Leaf $node$, the index position $i$ to the linked list $L$ and the time point to insert $t$}
	\KwResult{Linked List $L$  such that $t$ $\in$ $L$}
	\Begin{
		head $\leftarrow$ node.pointers[i]\;
		tail $\leftarrow$ head.prev\; 
		insert $t$ between head and tail\;	
		doubly link $t$ to head and tail\;
	}
	
	\caption{AddNewTail$(node, i, t)$}
	\label{AddToList}
\end{algorithm}


%AddvaluetoList

\begin{algorithm}[H]
	\IncMargin{1em}
	\DontPrintSemicolon
	\KwData{Leaf $node$ and index position $i$ for the position of the associated Linked List $L$}
	\KwResult{Linked List $L$ such that $t$ $\not\in$ $L$}
	
	\Begin{	

	elementToDelete $\leftarrow$ node.pointers[i]\;
	
	nextElement $\leftarrow$ elementToDelete.next\; 
	prevElement $\leftarrow$ elementToDelete.prev\; 
	\BlankLine
	//next is the second oldest key\;
	leaf.pointers[i] $\leftarrow$  next\;
	prevElement.next $\leftarrow$ nextElement\;
	prevElement.prev $\leftarrow$ prevElement\;
}

	\caption{DeleteHead$(node, i)$}
		\label{deleteListValue}
\end{algorithm}
%DeleteValueFromList

\subsubsection{Observation}
The linked list associated to the measurement key is used for storing the measurement time point. Every new time point that is added to an existing linked list always has a newer time point than all other time points in the list. Consequently, a new time point is always inserted at the tail position. Therefore, the linked list is always sorted by the time points from head to tail. A $shift$ operation on the circular array leads to a deletion of the oldest measurement in time series $s$, thus, the measurements time point, as explained, is always at the head position in a linked list. Also, a new measurement can be inserted without looping through the list. It is always added to the position before the oldest time point, the tail position. \\
The new\_neighborhood$(t,v,j,l)$operation searches a specific time point in the doubly, linked list. Therefore, it cannot just take the oldest or newest time point position like with an insertion or deletion. In the worst case the entire linked list would be searched for the specific time point. We initialize $l$ $\times$ $d$ neighborhoods, one for each value in a query pattern $Q(t)$. Thus, $l$ neighborhoods in every time series $r$ in the pattern. Hence, the new\_neighborhood$(t,v,j,l)$ operation always is executed at the $l$ newest measurements in a time series. Thus, we can give an upper bound, namely the pattern length $l$. Therefore, the worst case depends on the pattern length $l$. 

\newpage
\section{Operations}
\label{sec:OperationsOnBTree}
The data in the circular array is updated with every new arriving measurement. Therefore, with every $shift$ execution the array is updated. The update method is illustrated in Algrithm \ref{alg:UpdateCA}. The $shift$ operation not only influences the array data but also the data in the $B^+$tree. Therefore, the deletion and insertion of a measurement in the tree is executed within the update of the circular array. The implementation of an insertion and deletion within a $B^+$tree is described in Section \ref{sec:OperationsOnBTree}. The $lookup$ of a value is presented in Algorithm \ref{alg:Lookup}.
\\Further, the neighbor$(v,T)$ method uses the $B^+$tree returning the time point $t \in T$ such that $|v-s(t)|$ is minimal, given a value \emph{v}.

\begin{example}
We assume we have the situation illustrated in Figure \ref{startSituation}. 25.4 occurs two times, therefore two list values are part of the circular linked list associated to the key. Further, all keys in the leaves have an associated time point. Some associated linked lists are not illustrated to improve clarity. The size of the circular array is 14 and it is already full. This significances that for every new arriving measurement a value has to be added to and another one has to be deleted from the $B^+$tree. 
\end{example}

\begin{figure}[htbp]
	\centering
	\begin{tikzpicture}[
	scale=0.7,
	every node/.style={outer sep=0pt, transform shape, font=\scriptsize},
	every matrix/.style={cells={scale=0.7}},
	]
	% root node
	\xyshift{-20mm}{0mm}{\btreeinodethree{root}{17.1}{}{}};
	
	%
	% intermediate nodes
	\xyshift{-50mm}{-15mm}{\btreeinodethree{n1}{7.2}{}{}{}}
	\xyshift{ 10mm}{-15mm}{\btreeinodethree{n2}{23.0}{37.6}{43.1}}
	%
	% connecting root to intermediate level nodes
	\foreach \x in {1,2} { \btreelink{root-\x}{n\x} }
	%
	% leaf nodes
	\xyshift{-90mm}{-30mm}{\btreelnodethree{n11}{2.5}{3.0}{}}
	\xyshift{-60mm}{-30mm}{\btreelnodethree{n12}{7.2}{13.2}{}}
	\xyshift{-30mm}{-30mm}{\btreelnodethree{n21}{17.1}{18.1}{}}
	\xyshift{ 0mm}{-30mm}{\btreelnodethree{n22}{23.0}{25.4}{}}
	\xyshift{ 30mm}{-30mm}{\btreelnodethree{n23}{37.6}{38.9}{40.3}}
	\xyshift{ 60mm}{-30mm}{\btreelnodethree{n24}{43.1}{47.1}{}}
	%
	% connecting intermediate level to leaf nodes
	\foreach \x in {1,2}     { \btreelink{n1-\x}{n1\x} }
	\foreach \x in {1,2,3,4} { \btreelink{n2-\x}{n2\x} }
	%
	% leaf pointers
	\draw[btlink] ([yshift=+3pt] n11-c.east) -- ([yshift=+3pt] n12-a.west);
	\draw[btlink] ([yshift=-3pt] n12-a.west) -- ([yshift=-3pt] n11-c.east);
	\draw[btlink] ([yshift=+3pt] n12-c.east) -- ([yshift=+3pt] n21-a.west);
	\draw[btlink] ([yshift=-3pt] n21-a.west) -- ([yshift=-3pt] n12-c.east);
	\draw[btlink] ([yshift=+3pt] n21-c.east) -- ([yshift=+3pt] n22-a.west);
	\draw[btlink] ([yshift=-3pt] n22-a.west) -- ([yshift=-3pt] n21-c.east);
	\draw[btlink] ([yshift=+3pt] n22-c.east) -- ([yshift=+3pt] n23-a.west);
	\draw[btlink] ([yshift=-3pt] n23-a.west) -- ([yshift=-3pt] n22-c.east);
	\draw[btlink] ([yshift=+3pt] n23-c.east) -- ([yshift=+3pt] n24-a.west);
	\draw[btlink] ([yshift=-3pt] n24-a.west) -- ([yshift=-3pt] n23-c.east);
	%
	
	% circular array
	\xyshift{-40mm}{-60mm}{
		\matrix [ampersand replacement=\&, outer sep=0pt, matrix anchor=north] (array) {
			\node[circularptr] (c1)  {}; \\	
			%
			\node[circularval] (left)(right) {13:45}; \\
		};
	}
	% circular array
	\xyshift{-10mm}{-60mm}{
		\matrix [ampersand replacement=\&, outer sep=0pt, matrix anchor=north] (array) {
			\node[circularptr] (c2)  {}; \\	
			%
			\node[circularval] (left)(right) {14:15}; \\
		};
	}	
	
	% draw pointers between circular array and B+ tree
	\path[btlink2] ([yshift=-2pt] c1.center)  edge[out=90,in=270] ([yshift=2pt] n22-2.center);
	% draw pointers for linked list
	\draw[btlink] ([yshift=-10pt] c1.east) -- ([yshift=-10pt] c2.west);
	%\draw[btlink] ([yshift=-10pt] c2.east) -- ([yshift=-10pt] c1.east);
	\draw[btlink] ([yshift=-20pt] c2.west) -- ([yshift=-20pt] c1.east);
	
	%circular links
	\path[btlink] ([yshift=-10pt] c1.west)  edge[out=220,in=250] ([yshift=-10pt] c2.east);
	\path[btlink2] ([yshift=-20pt] c1.west)  edge[out=220,in=250] ([yshift=-20pt] c2.east);
	
	
	% list  value
	\xyshift{-90mm}{-50mm}{
		\matrix [ampersand replacement=\&, outer sep=0pt, matrix anchor=north] (array) {
			\node[circularptr] (c3)  {}; \\	
			%
			\node[circularval] (left)(right) {14:10}; \\
		};
	}
	
	% draw pointers between list value and B+ tree
	\path[btlink2] ([yshift=-2pt] c3.center)  edge[out=90,in=270] ([yshift=2pt] n11-1.center);
	
	%circular links
	\path[btlink] ([yshift=-16pt] c3.west)  edge[out=-1500,in=-60] ([yshift=-16pt] c3.east);
	\path[btlink2] ([yshift=-24pt] c3.west)  edge[out=-1500,in=-60] ([yshift=-24pt] c3.east);
	
	
	% list  value
	\xyshift{-70mm}{-50mm}{
		\matrix [ampersand replacement=\&, outer sep=0pt, matrix anchor=north] (array) {
			\node[circularptr] (c4)  {}; \\	
			%
			\node[circularval] (left)(right) {14:20}; \\
		};
	}
	
	% draw pointers between list value and B+ tree
	\path[btlink2] ([yshift=-2pt] c4.center)  edge[out=90,in=270] ([yshift=2pt] n11-2.center);
	
	%circular links
	\path[btlink] ([yshift=-16pt] c4.west)  edge[out=-1500,in=-60] ([yshift=-16pt] c4.east);
	\path[btlink2] ([yshift=-24pt] c4.west)  edge[out=-1500,in=-60] ([yshift=-24pt] c4.east);
	
	\foreach \x in
	{n12-1,n12-2,n21-1,n21-2,n22-1, n23-1, n23-2, n23-3, n24-1,n24-2}
	{ \path[<-] ([yshift=-15pt] \x.center) edge ([yshift=2pt] \x.center); }
	
	
	\definecolor{mycolor}{RGB}{224,224,224}
	
	% circular array
	\xyshift{-15mm}{-100mm}{
		\matrix [ampersand replacement=\&, outer sep=0pt, matrix anchor=north] (array) {
			\node[circularptr] (c1)  {2.5}; \&
			\node[circularptr] (c2)  {25.4}; \&
			\node[circularptr, fill=mycolor] (c3)  {3.0}; \&
			\node[circularptr] (c4)  {13.2}; \&
			\node[circularptr] (c5)  {23.0}; \&
			\node[circularptr] (c6)  {17.1}; \&
			\node[circularptr] (c7)  {37.6}; \&
			\node[circularptr] (c8)  {18.1}; \&
			\node[circularptr] (c9)  {7.2}; \&
			\node[circularptr] (c10) {25.4}; \&
			\node[circularptr] (c11) {38.9}; \&
			\node[circularptr] (c12) {47.1}; \&
			\node[circularptr] (c13) {43.1}; \&
			\node[circularptr] (c14) {40.3};  \\
			%
			\node[circularval] (left) {14:10}; \&
			\node[circularval] {14:15}; \&
			\node[circularval, fill=mycolor] {14:20}; \&
			\node[circularval] {13:15}; \&
			\node[circularval] {13:20}; \&
			\node[circularval] {13:25}; \&
			\node[circularval] {13:30}; \&
			\node[circularval] {13:35}; \&
			\node[circularval] {13:40}; \&
			\node[circularval] {13:45}; \&
			\node[circularval] {13:50}; \&
			\node[circularval] {13:55}; \&
			\node[circularval] {14:00}; \&
			\node[circularval] (right){14:05};\\
		};
	}
	% curly brace
	\draw [decorate,decoration={brace,mirror,amplitude=10pt}]
	([yshift=-5pt] left.south west) -- ([yshift=-5pt] right.south east)
	node [black,midway,yshift=-0.9cm] {\large size $|W|$};
	
	\end{tikzpicture}
	\vspace{2mm}

	\caption{Start situation}
	\label{startSituation}
	
\end{figure}


\subsection{Shift$(\bar{t}, v)$}

\subsubsection{Add a Value to the Circular Array}
The circular array has a $count$ attribute that is equal or smaller than the size of the array. It counts the number of measurements in the time series $s$. If the $count$ is equal to the size of the array one measurement has to be deleted for every new arriving measurement. If not, there is no need to delete a value from the $B^+$tree, since no value is overwritten in the circular array. 

\begin{algorithm}[H]
	\IncMargin{1em}
	\SetAlgoLined
	\DontPrintSemicolon
	\KwData{Tree $tree$, the circular array $array$, the new time point $t$ and the new value $v$}
	\KwResult{The updated array}
	\Begin{

	   newPos $\leftarrow$ 0\;
	   
	   \If{array.count < array.size}{
	   	
		   	//the array has no value yet\;
		   	\If{array.count $\neq$ 0}{
	   		newPos $\leftarrow$ (array.lastUpdatePosition + 1) \%array.size\;
		   	}
		   	array.count++\;
	   }
	   \Else{
	   	newUpdatePosition $\leftarrow$ (array.lastUpdatePosition + 1) \%array.size\;
	   	//delete measurement from tree\;
	   	delete(tree, array.data[newPos].time, array.data[newPos].value)\;
	   	
	   }
	   
	   array.data[newPos].time $\leftarrow$ newTime\;
	   array.data[newPos].value $\leftarrow$ newValue\;
	   array.lastUpdatePosition $\leftarrow$ newPos\;
	   
	   addRecordToTree(tree, newTime, newValue)\;
	}

	\caption{Update the Circular Array}
		\label{alg:UpdateCA}
\end{algorithm}

%updateCircularArray


\begin{exmp}
	We assume that a new measurement arrives with time point $\text{14:25}$ and key $41.5$. 
	The value $13.2$ at time point $\text{13:15}$ is overwritten by the new measurement. The new circular array looks as follows: 
\end{exmp}
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[
	scale=0.7,
	every node/.style={outer sep=0pt, transform shape, font=\scriptsize},
	every matrix/.style={cells={scale=0.7}},
	]
	
	\definecolor{mycolor}{RGB}{224,224,224}
	
	% circular array
	\xyshift{-15mm}{-100mm}{
		\matrix [ampersand replacement=\&, outer sep=0pt, matrix anchor=north] (array) {
			\node[circularptr] (c1)  {2.5}; \&
			\node[circularptr] (c2)  {25.4}; \&
			\node[circularptr,fill=mycolor] (c3)  {3.0}; \&
			\node[circularptr](c4) {41.5}; \&
			\node[circularptr] (c5)  {23.0}; \&
			\node[circularptr] (c6)  {17.1}; \&
			\node[circularptr] (c7)  {37.6}; \&
			\node[circularptr] (c8)  {18.1}; \&
			\node[circularptr] (c9)  {7.2}; \&
			\node[circularptr] (c10) {25.4}; \&
			\node[circularptr] (c11) {38.9}; \&
			\node[circularptr] (c12) {47.1}; \&
			\node[circularptr] (c13) {43.1}; \&
			\node[circularptr] (c14) {40.3};  \\
			%
			\node[circularval] (left) {14:10}; \&
			\node[circularval] {14:15}; \&
			\node[circularval,fill=mycolor] {14:20}; \&
			\node[circularval]{13:15}; \&
			\node[circularval] {13:20}; \&
			\node[circularval] {13:25}; \&
			\node[circularval] {13:30}; \&
			\node[circularval] {13:35}; \&
			\node[circularval] {13:40}; \&
			\node[circularval] {13:45}; \&
			\node[circularval] {13:50}; \&
			\node[circularval] {13:55}; \&
			\node[circularval] {14:00}; \&
			\node[circularval] (right){14:05};\\
		};
	}
	
	\end{tikzpicture}
	\vspace{2mm}
	\caption{Circular Array before}
	\label{fig:circAfter}
\end{figure}


\begin{figure}[htbp]
	\centering
	\begin{tikzpicture}[
	scale=0.7,
	every node/.style={outer sep=0pt, transform shape, font=\scriptsize},
	every matrix/.style={cells={scale=0.7}},
	]
	
	\definecolor{mycolor}{RGB}{224,224,224}
	
		% circular array
		\xyshift{-15mm}{-100mm}{
			\matrix [ampersand replacement=\&, outer sep=0pt, matrix anchor=north] (array) {
				\node[circularptr] (c1)  {2.5}; \&
				\node[circularptr] (c2)  {25.4}; \&
				\node[circularptr] (c3)  {3.0}; \&
				\node[circularptr,fill=mycolor](c4) {13.2}; \&
				\node[circularptr] (c5)  {23.0}; \&
				\node[circularptr] (c6)  {17.1}; \&
				\node[circularptr] (c7)  {37.6}; \&
				\node[circularptr] (c8)  {18.1}; \&
				\node[circularptr] (c9)  {7.2}; \&
				\node[circularptr] (c10) {25.4}; \&
				\node[circularptr] (c11) {38.9}; \&
				\node[circularptr] (c12) {47.1}; \&
				\node[circularptr] (c13) {43.1}; \&
				\node[circularptr] (c14) {40.3};  \\
				%
				\node[circularval] (left) {14:10}; \&
				\node[circularval] {14:15}; \&
				\node[circularval] {14:20}; \&
				\node[circularval,fill=mycolor]{14:25}; \&
				\node[circularval] {13:20}; \&
				\node[circularval] {13:25}; \&
				\node[circularval] {13:30}; \&
				\node[circularval] {13:35}; \&
				\node[circularval] {13:40}; \&
				\node[circularval] {13:45}; \&
				\node[circularval] {13:50}; \&
				\node[circularval] {13:55}; \&
				\node[circularval] {14:00}; \&
				\node[circularval] (right){14:05};\\
			};
		}

	\end{tikzpicture}
		\vspace{2mm}
		\caption{Circular Array after the insertion of 41.5}
		\label{fig:circAfter}
\end{figure}


\newpage
\subsubsection{Searching in the $B^+$tree}
Before we can delete or add a measurement to the $B^+$tree, we have to find the right leaf. 
Algorithm $FindLeaf$ presents the pseudo-code to find the appropriate leaf. 


%FindLeaf

\begin{algorithm}[H]
	\IncMargin{1em}
	\SetAlgoLined
	\DontPrintSemicolon
	\KwData{Tree $tree$ and the searchkey $k$}
	\KwResult{The appropriate leaf for the searchkey $k$}
	\Begin{
		curNode $\leftarrow$ tree.root\; 
		
		\If{curNode = NIL}{
			return curNode\;
		}
		\While{curNode is no Leaf}{
		Let $i$ $\leftarrow$ smallest number such that $k$ $\leq$ curNode.$K_i$\;
		\eIf{no $i$}{
			$m$ $\leftarrow$ last non-null pointer in the node\;
			curNode $\leftarrow$ curNode.$P_m$\;
		}
		{
			curNode $\leftarrow$ curNode.$P_i$\;
		}	
	}
	
	return curNode\;
}

	\caption{FindLeaf}	\label{findLeaf}
\end{algorithm}

\begin{example}
	Assume we want to find the key value $13.2$ in the $B^+$tree, since this is the one that has been overwritten by the newly arrived measurement in Figure \ref{fig:circAfter}. The function starts at the root of the tree, and goes through the tree until it reaches a leaf node that would contain the searched value. 
	The current node is examined by looking for the smallest $i$ for which the searchkey value $13.2$ is greater or equal to. The Figure \ref{startSituation} illustrates the  $B^+$tree. In this case the first pointer comes from the root at index position $0$, since $13.2$ is smaller than $17.1$. Then the new current node is set to the child node at pointer position $0$. Then the procedure is repeated until a leaf node is reached. 
\end{example} 

\subsubsection{Delete a Value from the $B^+$tree}
\label{delete}
The circular array update Algorithm first deletes a value if necessary and then adds the new value to the tree. Since the deletion is executed first, we first present the deletion. \\
At the beginning, the leaf for the measurement to delete is located. 
Since our $B^+$tree accepts duplicates, it is afterwards checked if the associated linked list to the measurement key has multiple list values. If the list has multiple list values, the identified list value is deleted and the deletion is already finished. \\
But if the entries time point is the single value in the linked list the key and its belonging linked list is deleted. Therefore, $DeleteEntry$ is called.\\
After removing the entry from the node, there are three possible options: 
\begin{itemize}
	\item The node has still enough keys: The minimum number of keys depends on the node properties. If the node is a leaf node it contains at least $\ceil{(n-1)/2}$ keys. If the node is an internal node the minimum number of keys is $\ceil{n/2}-1$ and the minimum number of pointers is $\ceil{n/2}$. 
	\begin{figure}[ht!]
		\centering
		\begin{tikzpicture}[
		scale=0.7,
		every node/.style={outer sep=0pt, transform shape, font=\scriptsize},
		every matrix/.style={cells={scale=0.7}},
		]
		% root node
		\xyshift{-20mm}{0mm}{\btreeinodethree{root}{17.2}{}{}};
		
		%
		% intermediate nodes
		\xyshift{-50mm}{-15mm}{\btreelnodethree{n1}{7.5}{16.4}{}{}}
		\xyshift{ 10mm}{-15mm}{\btreelnodethree{n2}{17.2}{33.1}{43.5}}
		%
		% connecting root to leaf level nodes
		\foreach \x in {1,2} { \btreelink{root-\x}{n\x} }
		%
		% leaf pointers
		\draw[btlink] ([yshift=+3pt] n1-c.east) -- ([yshift=+3pt] n2-a.west);
		\draw[btlink] ([yshift=-3pt] n2-a.west) -- ([yshift=-3pt] n1-c.east);
		%
		
		
			% root node
			\xyshift{90mm}{0mm}{\btreeinodethree{xroot}{17.2}{}{}};
				
				%
			% intermediate nodes
			\xyshift{60mm}{-15mm}{\btreelnodethree{xn1}{7.5}{16.4}{}{}}
			\xyshift{ 110mm}{-15mm}{\btreelnodethree{xn2}{17.2}{43.5}{}}
				%
			% connecting root to leaf level nodes
			\foreach \x in {1,2} { \btreelink{xroot-\x}{xn\x} }
			%
			% leaf pointers
			\draw[btlink] ([yshift=+3pt] xn1-c.east) -- ([yshift=+3pt] xn2-a.west);
			\draw[btlink] ([yshift=-3pt] xn2-a.west) -- ([yshift=-3pt] xn1-c.east);
			%
				
		
		\draw[->]  (2,-1) -- (5,-1) node [pos=0.5,above,font=\footnotesize] {delete $33.1$};
		
		
		\end{tikzpicture}
		\vspace{2mm}
		\caption{Option 1: The node has still enough keys}
		\label{fig:enoughkeys}
	\end{figure} 
		
	\item The node needs to be merged with a sibling node: We merge the nodes by moving the entries from both the nodes into the left sibling, and deleting the
	now empty right sibling. If there is no left sibling the right sibling is selected. Once the node is deleted, we must also delete the entry in the parent node that pointed to the deleted node. Hence, we traverse the tree upwards recursively until $deleteEntry$ stops.
	
	\begin{figure}[ht!]
		\centering
		\begin{tikzpicture}[
		scale=0.7,
		every node/.style={outer sep=0pt, transform shape, font=\scriptsize},
		every matrix/.style={cells={scale=0.7}},
		]
		% root node
		\xyshift{-20mm}{0mm}{\btreeinodethree{root}{17.2}{50.1}{}};
		
		%
		% intermediate nodes
		\xyshift{-50mm}{-15mm}{\btreelnodethree{n1}{7.5}{16.4}{}{}}
		\xyshift{ -20mm}{-15mm}{\btreelnodethree{n2}{17.2}{33.1}{}}
		\xyshift{ 10mm}{-15mm}{\btreelnodethree{n3}{50.1}{52.1}{}}
		%
		% connecting root to leaf level nodes
		\foreach \x in {1,2, 3} { \btreelink{root-\x}{n\x} }
		%
		% leaf pointers
		\draw[btlink] ([yshift=+3pt] n1-c.east) -- ([yshift=+3pt] n2-a.west);
		\draw[btlink] ([yshift=-3pt] n2-a.west) -- ([yshift=-3pt] n1-c.east);
		\draw[btlink] ([yshift=+3pt] n2-c.east) -- ([yshift=+3pt] n3-a.west);
		\draw[btlink] ([yshift=-3pt] n3-a.west) -- ([yshift=-3pt] n2-c.east);
		%
		% root node
		\xyshift{90mm}{0mm}{\btreeinodethree{root}{17.2}{}{}};
			
			%
		% intermediate nodes
		\xyshift{60mm}{-15mm}{\btreelnodethree{n1}{7.5}{16.4}{}{}}
		\xyshift{ 120mm}{-15mm}{\btreelnodethree{n2}{17.2}{33.1}{52.1}}
		%
		% connecting root to leaf level nodes
		\foreach \x in {1,2} { \btreelink{root-\x}{n\x} }
			%
		% leaf pointers
		\draw[btlink] ([yshift=+3pt] n1-c.east) -- ([yshift=+3pt] n2-a.west);
		\draw[btlink] ([yshift=-3pt] n2-a.west) -- ([yshift=-3pt] n1-c.east);
		%
		
		\draw[->]  (2,-1) -- (5,-1) node [pos=0.5,above,font=\footnotesize] {delete $50.1$};
		
		
		\end{tikzpicture}
		\vspace{2mm}
		\caption{Option 2: The node can be merged with its sibling}
		\label{fig:enoughkeys}
	\end{figure} 
	
	
	\item The values in the node have to be redistributed to ensure that each node is at least half-full and hence contains the minimum number of keys. Merging is not possible, if the sibling and node together have more than the allowed $n$ pointers. Thus, the nodes have to be redistributed. We redistribute the keys, such that each node has at least $\ceil{n/2}$ child pointers. Therefore, we move the rightmost pointer from the left sibling to the under-full right sibling. Hence, we also need to move a key so that the newly added pointer is separable. This pointer is neither present in the left sibling nor in the right sibling. So we take a key from the parent node.
		\begin{figure}[ht!]
			\centering
			\begin{tikzpicture}[
			scale=0.7,
			every node/.style={outer sep=0pt, transform shape, font=\scriptsize},
			every matrix/.style={cells={scale=0.7}},
			]
			% root node
			\xyshift{-20mm}{0mm}{\btreeinodethree{root}{17.2}{50.1}{}};
			
			%
			% intermediate nodes
			\xyshift{-50mm}{-15mm}{\btreelnodethree{n1}{7.5}{16.4}{}{}}
			\xyshift{ -20mm}{-15mm}{\btreelnodethree{n2}{17.2}{33.1}{34.2}}
			\xyshift{ 10mm}{-15mm}{\btreelnodethree{n3}{50.1}{52.1}{}}
			%
			% connecting root to leaf level nodes
			\foreach \x in {1,2, 3} { \btreelink{root-\x}{n\x} }
			%
			% leaf pointers
			\draw[btlink] ([yshift=+3pt] n1-c.east) -- ([yshift=+3pt] n2-a.west);
			\draw[btlink] ([yshift=-3pt] n2-a.west) -- ([yshift=-3pt] n1-c.east);
			\draw[btlink] ([yshift=+3pt] n2-c.east) -- ([yshift=+3pt] n3-a.west);
			\draw[btlink] ([yshift=-3pt] n3-a.west) -- ([yshift=-3pt] n2-c.east);
			%
			% root node
			\xyshift{90mm}{0mm}{\btreeinodethree{xroot}{17.2}{34.2}{}};
			
			%
			% intermediate nodes
			\xyshift{60mm}{-15mm}{\btreelnodethree{xn1}{7.5}{16.4}{}{}}
			\xyshift{ 90mm}{-15mm}{\btreelnodethree{xn2}{17.2}{33.1}{}}
			\xyshift{ 120mm}{-15mm}{\btreelnodethree{xn3}{34.2}{52.1}{}}
			%
			% connecting root to leaf level nodes
			\foreach \x in {1,2, 3} { \btreelink{xroot-\x}{xn\x} }
			%
			% leaf pointers
			\draw[btlink] ([yshift=+3pt] xn1-c.east) -- ([yshift=+3pt] xn2-a.west);
			\draw[btlink] ([yshift=-3pt]xn2-a.west) -- ([yshift=-3pt] xn1-c.east);
			\draw[btlink] ([yshift=+3pt] xn2-c.east) -- ([yshift=+3pt] xn3-a.west);
			\draw[btlink] ([yshift=-3pt] xn3-a.west) -- ([yshift=-3pt] xn2-c.east);
			%
			
			\draw[->]  (2,-1) -- (5,-1) node [pos=0.5,above,font=\footnotesize] {delete $50.1$};
			
			
			\end{tikzpicture}
			\vspace{2mm}
			\caption{Option 3: The values are redistributed}
			\label{fig:enoughkeys}
		\end{figure} 
	
	
\end{itemize} 
As a result of deletion, a key value that is present in an interior node or in the root node of the $B+$tree may not be present at any leaf of the tree any more. 


\begin{algorithm}[H]
	\IncMargin{1em}
	\SetAlgoLined
	\DontPrintSemicolon
	\KwData{Tree $tree$, the measurement with its time point $t$ and its key $k$}
	\KwResult{Deletes measurement form $tree$}
	\Begin{

		leaf $\leftarrow$ findLeaf($tree$, $k$)\; 
		
		i $\leftarrow$ right position index in leaf\;
					\BlankLine
		\eIf{list on pointer at position i has multiple elements}{
						\BlankLine

			deleteHead(leaf, keyPositionIndex)\;
		}
		{

			deleteEntry(tree,leaf, key on keyPostionIndex)\; 
		}	
	}

	\caption{Delete$(tree, t, k)$}	\label{delete}
\end{algorithm}
%Delete


\begin{exmp}
	We again refer to the example in Figure \ref{startSituation}. The measurement with time point $\text{13:15}$ is overwritten by the new value. Therefore, it needs to be deleted from the $B^+$tree before the new value is added. First, the $findLeaf$ method finds the leaf where $13.2$ is located. Then it deletes the value and its associated linked list. The leaf after has just 1 value left and therefore is smaller than the minimum allowed keys of $\ceil{(n-1)/2}$. Since $1<\ceil{(4-3)/2}$. The left neighbor has still enough space for the only key left in the node, namely, $7.2$. The node is merged with its left sibling. After the key in the parent is not right any more. Since $7.2$ now is part of the left child. The key $7.2$ in the parent is removed as well by calling $DeleteEntry$ at the end of $MergeNodes$. Then the $DeleteEntry$ procedure checks weather this node can be merged with its sibling. Since the node has one pointer left to its now only child and the sibling has already three keys, $23.0,37.6, 43.1$ and hence 4 pointers. So $1+4$ is more than the allowed $4$ pointers in an inner node. So the keys have to be redistributed. The node takes the root nodes key $17.1$ as new key and gets the leftmost child of the sibling. This is the leaf node with the keys $17.1$ and $18.1$. The root node takes the leftmost key of its right children, so $23.0$. The right children now has the keys $37.6$ and $43.1$ left. 
	As a result, the tree after deleting $13.2$ looks as follows: 
\end{exmp}
\begin{figure}[htbp]
	\centering
	\begin{tikzpicture}[
	scale=0.7,
	every node/.style={outer sep=0pt, transform shape, font=\scriptsize},
	every matrix/.style={cells={scale=0.7}},
	]
	% root node
	\xyshift{-30mm}{0mm}{\btreeinodethree{root}{23.0}{}{}};
	
	%
	% intermediate nodes
	\xyshift{-50mm}{-15mm}{\btreeinodethree{n1}{17.1}{}{}{}}
	\xyshift{ 0mm}{-15mm}{\btreeinodethree{n2}{37.6}{43.1}{}}
	%
	% connecting root to intermediate level nodes
	\foreach \x in {1,2} { \btreelink{root-\x}{n\x} }
	%
	% leaf nodes
	\xyshift{-90mm}{-30mm}{\btreelnodethree{n11}{2.5}{3.0}{7.2}}
	\xyshift{-60mm}{-30mm}{\btreelnodethree{n12}{17.1}{18.1}{}}
	\xyshift{-30mm}{-30mm}{\btreelnodethree{n21}{23.0}{25.4}{}}
	\xyshift{ 0mm}{-30mm}{\btreelnodethree{n22}{37.6}{38.9}{40.3}}
	\xyshift{ 30mm}{-30mm}{\btreelnodethree{n23}{43.1}{47.1}{}}
	%
	% connecting intermediate level to leaf nodes
	\foreach \x in {1,2}     { \btreelink{n1-\x}{n1\x} }
	\foreach \x in {1,2,3} { \btreelink{n2-\x}{n2\x} }
	%
	% leaf pointers
	\draw[btlink] ([yshift=+3pt] n11-c.east) -- ([yshift=+3pt] n12-a.west);
	\draw[btlink] ([yshift=-3pt] n12-a.west) -- ([yshift=-3pt] n11-c.east);
	\draw[btlink] ([yshift=+3pt] n12-c.east) -- ([yshift=+3pt] n21-a.west);
	\draw[btlink] ([yshift=-3pt] n21-a.west) -- ([yshift=-3pt] n12-c.east);
	\draw[btlink] ([yshift=+3pt] n21-c.east) -- ([yshift=+3pt] n22-a.west);
	\draw[btlink] ([yshift=-3pt] n22-a.west) -- ([yshift=-3pt] n21-c.east);
	\draw[btlink] ([yshift=+3pt] n22-c.east) -- ([yshift=+3pt] n23-a.west);
	\draw[btlink] ([yshift=-3pt] n23-a.west) -- ([yshift=-3pt] n22-c.east);
	
	%
	
	\foreach \x in
	{n11-1,n11-2,n11-3,n12-1,n12-2,n21-1,n21-2,n22-1,n22-2, n22-3, n23-1, n23-2}
	{ \path[<-] ([yshift=-15pt] \x.center) edge ([yshift=2pt] \x.center); }
	%
	
	
	
	\end{tikzpicture}
	\vspace{2mm}
	\caption{$B^+$tree after the deletion of $13.2$}
	\label{fig:deletionOf13}
\end{figure}

\begin{algorithm}[H]
	\IncMargin{1em}
	\SetAlgoLined
	\DontPrintSemicolon
	\KwData{Tree $tree$}
	\KwResult{The $tree$ with an adjusted root node}
	\Begin{
		//enough keys in the root\;
		\If{0 < tree.root.numOfKeys}{
			return\; 	
		}
		//if the root has a child, promote the first (only) child as the new root\;
		\eIf{root is leaf}{
			newRoot $\leftarrow$ tree.root.pointers[0]\;
			newRoot.parent $\leftarrow$ NIL\;
		}
		{
			newRoot $\leftarrow$ NIL\;
		}
		
		tree.root $\leftarrow$ newRoot\;
	}
	\caption{AdjustTheRoot$(tree)$}	\label{deleteEntry}
\end{algorithm}




\begin{algorithm}[H]
	\IncMargin{1em}
	\SetAlgoLined
	\DontPrintSemicolon
	\KwData{Tree $tree$, the node $node$ where the deletion key belongs to, $k$ the key to delete}
	\KwResult{$k$ $\not\in$$node$}
	\Begin{

		node $\leftarrow$ remove $k$ from $node$\; 
		\If{node is the root}{
			adjustTheRoot$(tree)$\;
			return\; 	
		}
		\eIf{node is leaf}{
			minNrOfKeys $\leftarrow$ $\ceil{(n-1)/2}$\;
		}
		{
			minNrOfKeys $\leftarrow$ $\ceil{n/2}-1$\;
		}
			
		\If{minNrOfKeys $\leq$ number of keys left in node}{
			//node has still enough keys\; 
			return\;
		}	
		
		//node has not enough keys - merge or rearranges necessary\; 
		neighborIndex $\leftarrow$ get pointer position of left sibling in parent node\;
		
		\eIf{no left sibling}{
			kIndex $\leftarrow$ 0; \;
			neighbor $\leftarrow$ node.parent.pointers[1]\;
		}
		{
			kIndex $\leftarrow$ neighborIndex; \;
			neighbor $\leftarrow$ node.parent.pointers[neighborIndex]\;
		}
		//keyPrime is the value between pointers to $node$ and $neighbor$ in parent\;
		innerKeyPrime $\leftarrow$ node.parent.pointers[kIndex]
		
		capacity $\leftarrow$ treeNodeSize\;	
	
		\If{node is a leaf}{
			capacity $\leftarrow$ treeNodeSize + 1\;
		}

		//Merge if both nodes together have enough space\;
		\eIf{(neighbor.numOfKeys + node.numOfKeys ) < capacity}{
		  	mergeNodes(tree, node, neighbor, neighbourIndex, innerKeyPrime)\;
		 }
		 {
		  	redestributeNodes(tree, node, neighbor, neighbourIndex, kIndex, innerKeyPrime)\;
		}   
	}
	

	\caption{DeleteEntry$(tree, node, k, pointer)$}	\label{deleteEntry}
\end{algorithm}
%DeleteEntry



\begin{algorithm}[H]
	\IncMargin{1em}
	\SetAlgoLined
	\DontPrintSemicolon
	\KwData{Tree $tree$, the node $node$ and its neighbor $neighbor$, the neighborIndex $nIndex$ and the key $kPrime$}
	\KwResult{$node$ and its $neighbor$ are merged to one node}
    \Begin{
    //Swap neighbor with node if node is on the extreme left and neighbor is to its right\;
    \If{node is leftmost}{
    	swap neighbor with node\;
    }
	neighborInsertionIndex $\leftarrow$ neighbor.numOfKeys\;
   
   //Append kPrime and the following pointers\;
    \eIf{node is no leaf}{
    	neighbor.keys[neighborInsertionIndex] $\leftarrow$ kPrime\;
    	neighbor.numOfKeys++\;
    	decreasingIndex $\leftarrow$ 0\;
    	numOfKeysBefore $\leftarrow$ node.numOfKeys\;
    	\For{i $\leftarrow$ neighborInsertionIndex + 1, j $\leftarrow$ 0; j < node.numOfKeys;}{
    	\BlankLine
    		neighbor.keys[i] $\leftarrow$ node.keys[j]\;
    		neighbor.pointers[i] $\leftarrow$ node.pointers[j]\;
    		neighbor.numOfKeys++\;
    		decreasingIndex++\;
    		i++, j++\;
    	}
    	node.numOfKeys $\leftarrow$ numOfKeysBefore - decreasingIndex\;
    	neighbor.pointers[i] $\leftarrow$ node.pointers[j]\;
    	\BlankLine
    	//All children must now point up to the same parent\;
    	\For{i $\leftarrow$ 0; i < neighbor.numOfKeys + 1; i++}{
    		tmp $\leftarrow$ neighbor.pointers[i]\;
    		tmp.parent $\leftarrow$ neighbor\;
    	}
    
    }
    {
    	 // a leaf, append the keys and pointers of the node to the neighbor\;
    	 //Set the neighbor's last pointer to point to what had been the node's right neighbor\;
    	
    	   \For{i $\leftarrow$ neighborInsertionIndex, j $\leftarrow$ 0; j < node.numOfKeys}{
    	   	neighbor.keys[i] $\leftarrow$ node.keys[j]\;
    	   	neighbor.pointers[i] = node.pointers[j]\;
    	   	neighbor.numOfKeys++\;
    	   	i++, j++\;
    	   }
    	  
	       relink leaves\;
	}
	deleteEntry(tree, node.parent, kPrime, node)\;

}

	\caption{MergeNodes}	\label{MergeNodes}
\end{algorithm}
%Merge

\begin{algorithm}[H]
	\IncMargin{1em}
	\SetAlgoLined
	\DontPrintSemicolon
	\KwData{Tree $tree$, the node $node$ and its neighbor $neighbor$, the neighborIndex $nIndex$, the $kIndex$ and the the key $kPrime$}
	\KwResult{The keys in the node and its neighbor, as well as the parents keys are redestributed}

\Begin{
	 
	\eIf{node has neighbor to the left side}{
		//Pull the neighbor's last key-pointer pair over from the neighbor's right end to n's 
		\eIf{node is not a leaf}{
			m $\leftarrow$ neighbor.pointer[neighbor.numOfKeys]\;
			insert neighbor.pointers[m] and $kPrime$ to first position in node and shift other pointers and values right
			remove neighbor.key[m-1], neighbor.pointers[m] from neighbor\;
			replace $kPrime$ in node.parent by neighbor.keys[m-1]\;}
		{
		//last value pointer pair in the node\;
		m $\leftarrow$ neighbor.pointer[neighbor.numOfKeys -1]\;
		insert neighbor.pointers[m] and neighbor.keys[m] to first position in node and shift other pointers and values right
		remove neighbor.key[m], neighbor.pointers[m] from neighbor\;
		replace $kPrime$ in node.parent by node.keys[0]\;
		}
		
	}	
	{
		//node is leftmost child. Take a key-pointer pair from the neighbor to the right\;
		//Move the neighbor's leftmost key-pointer pair to n's rightmost position\;
		\eIf{node is not a leaf}{
			node.keys[node.numOfKeys] $\leftarrow$ $kPrime$\;
			node.pointers[node.numOfKeys +1] $\leftarrow$ neighbor.pointers[0]\;
			replace $kPrime$ in node.parent by neighbor.keys[0]\;
			remove neighbor.keys[0], neighbor.pointers[0] from neighbor\;}
		{
			node.keys[node.numOfKeys] $\leftarrow$ neighbor.keys[0]\;
			node.pointers[node.numOfKeys +1] $\leftarrow$ neighbor.pointers[0]\;
		    node.parent.keys[kIndex] = neighbor.keys[1]\;
		    remove neighbor.keys[0], neighbor.pointers[0] from neighbor\;
			}
	}
		
	
}	

	

	\caption{Redistribute}	\label{Redistribute}
\end{algorithm}
%Redistribute


\newpage
\subsubsection{Insert a Value to the $B^+$tree}
With every circular array update a new measurement is added to the $B^+$tree as shown in Algorithm \ref{alg:UpdateCA} line 12.\\
We first find the leaf node where the key would
appear by using $findLeaf()$. We then insert an entry, positioning it such that the search keys are still in order. Besides, a new doubly, circular linked list is allocated where the time point is inserted. If the searchkey already exists in the leaf node, the time point of the measurement is added to the already existing associated list and the searchkeys in the leaf remain unchanged. If the searchkey is new, it is inserted to the leaf. \\
The measurement is directly inserted to the leaf if there is still space left. The measurement is inserted, such that the leaf keys are still ordered from left to right. \\
The $splitAndInsertIntoInnerNode$ method works with the same principle as the $splitLeaves$ method. The difference is that if the inner nodes are split, one key is not included to the inner node but is given one level up to the parent of the splitted nodes. This searchkey separates the children. \\
%addRecordToTree
\begin{algorithm}[H]
	\IncMargin{1em}
	\SetAlgoLined
	\DontPrintSemicolon
	\KwData{Tree $tree$, the new time point $time$ and the new value $value$}
	\KwResult{The tree includes the new value $value$}
	
	\Begin{
		

		 //the tree does not exist yet - create tree\;
		 \If{tree.root = NIL}{
			 	newTree(tree, time, value)\;
			 	return\;	
		 }
		    
		 leaf $\leftarrow$ findLeaf(tree, value)\;
		//insert to leaf as doubly linked list value\;
		    \uIf{isDuplicateKey(leaf, time, value)}{
		    	addDuplicateToDoublyLinkedList(leaf, time, value)\;
		    }
		    \uElseIf{leaf.numOfKeys < tree.nodeSize}{
		    	//enough space for new key value pair\;
		    	insertRecordIntoLeaf(tree, leaf, time, value)\;
		    }
		    \Else{
		    	//leaf must be split\;
		    	splitAndInsertIntoLeaves(tree, leaf, time, value);\
		    }
	
	}	
	
	

	\caption{AddMeasurement}	\label{AddMeasurement}
\end{algorithm}

%split leaf

\begin{algorithm}[H]
	\IncMargin{1em}
	\SetAlgoLined
	\DontPrintSemicolon
	\KwData{Tree $tree$, the node $node$ and its neighbor $neighbor$, the neighborIndex $nIndex$, the $kIndex$ and the the key $kPrime$}
	\KwResult{The keys in the node and its neighbor, as well as the parents keys are redestributed}
	
	\Begin{

		   insertPoint $\leftarrow$ 0\;
		   int nrOfTempKeys $\leftarrow$ 0\;
		   insertPoint $\leftarrow$ getInsertPoint(tree, oldNode, firstValue)\;
		   
		   //fills the keys and pointers\;
		   \For{i = 0, j = 0; i < oldNode.numOfKeys;} {
		   	
		   	//if value is entered in the first position: pointers needs to be moved 1 position\;
		   	if (j = insertPoint){
		   		j++\;
		   	}
		   	tempKeys[j] = oldNode.keys[i]\;
		   	tempPointers[j] = oldNode.pointers[i]\;
		   	i++, j++\;
		   }
		   
		   //enter the record to the right position\;
		   tempKeys[insertPoint] $\leftarrow$ firstValue\;
		   
		   newListValueTime $\leftarrow$ new list value with time $time$\;
		   tempPointers[insertPoint] $\leftarrow$ newTime\;
		   
		   newNode.numOfKeys $\leftarrow$ 0\;
		   oldNode.numOfKeys $\leftarrow$ 0\;
		   \BlankLine
		   //calculate splitpoint by $\ceil{n/2}$\;
		   split = getSplitPoint(tree.nodeSize)\;
		   
		   //fill first leaf\;
		   \For{i = 0; i < split;)} {
		   	oldNode.keys[i] $\leftarrow$ tempKeys[i]\;
		   	oldNode.pointers[i] $\leftarrow$ tempPointers[i]\;
		   	 i++\;
		   }
		   
		   
		   //fill second leaf\;
		   \For{j = 0, i = split; i < nrOfTempKeys;} {
		   	newNode.keys[j] $\leftarrow$ tempKeys[i]\;
		   	newNode.pointers[j] $\leftarrow$ tempPointers[i]\;
		   	i++, j++\;
		   }
		   
		   link leaves\;

		   //the record to insert in upper node\;
		   keyForParent\;
		   keyForParent $\leftarrow$ newNode.keys[0]\;
		   
		   insertIntoParent(tree, oldNode, keyForParent, newNode)\;
	}	
	
	

	\caption{SplitLeaves}	\label{SplitLeaves}
\end{algorithm}

%insertinto parent
\begin{algorithm}[H]
	\IncMargin{1em}
	\SetAlgoLined
	\DontPrintSemicolon
	\KwData{Tree $tree$, the newly created $node$ and the $oldnode$ and the key $k$ which is inserted to the parent}
	\KwResult{The key $k$ is inserted to the parent or the parent is split}
	
	\Begin{
		  
		  parent $\leftarrow$ oldnode.parent\;
		  
		  \If{parent = NIL}{
		  	insertIntoANewRoot(tree, oldnode, newKey, newChild)\;
		  	return\;
		  }
		  
		  //Find the parents pointer from the old node\;
		  pointerPos $\leftarrow$ pointer position from parent to $oldnode$\;
		  
		  //the new key fits into the node\;
		  \eIf {parent.numOfKeys < tree.nodeSize}{
		  	insertIntoTheNode(parent, pointerPos, newKey, newChild)\;
		  }
		  {
		  	splitAndInsertIntoInnerNode(tree, parent, pointerPos, newKey, newChild)\;
		  }
	}	
	
	

	\caption{InsertIntoParent}	\label{InsertIntoParent}
\end{algorithm}


\begin{exmp}
We now consider the example from the beginning in Figure \ref{startSituation}, where $41.5$ has been inserted to the circular array. The measurement which already has been inserted to the circular array belongs to a leaf node which is already full. Hence, the $InsertIntoParent()$ method is executed and we find out that the parent is full as well. Therefore, the parent is split to a new node and the old node using the same principle as in the $split Leaf$ method. Therefore, the algorithm is not shown again. After, we see that the parent of the inner node is not full yet. Also, the parent is at the same time the root node. The new new nodes leftmost key is used to insert into the root. We see that the insertion is recursive from the leaves till the root until a node with enough space is found. If the root node is already full the root node would be split as well and a new root node would be allocated. But in our case the root node just gets a new key. Its child nodes are split but the key is not inserted. The new key is just inserted to the root node. Therefore, the new tree after inserting the new measurement looks as follows:  
\end{exmp}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[
	scale=0.7,
	every node/.style={outer sep=0pt, transform shape, font=\scriptsize},
	every matrix/.style={cells={scale=0.7}},
	]
	% root node
	\xyshift{-30mm}{0mm}{\btreeinodethree{root}{23.0}{}{}};
	
	%
	% intermediate nodes
	\xyshift{-50mm}{-15mm}{\btreeinodethree{n1}{17.1}{}{}{}}
	\xyshift{ 0mm}{-15mm}{\btreeinodethree{n2}{37.6}{40.3}{43.1}}
	%
	% connecting root to intermediate level nodes
	\foreach \x in {1,2} { \btreelink{root-\x}{n\x} }
	%
	% leaf nodes
	\xyshift{-90mm}{-30mm}{\btreelnodethree{n11}{2.5}{3.0}{7.2}}
	\xyshift{-60mm}{-30mm}{\btreelnodethree{n12}{17.1}{18.1}{}}
	\xyshift{-30mm}{-30mm}{\btreelnodethree{n21}{23.0}{25.4}{}}
	\xyshift{ 0mm}{-30mm}{\btreelnodethree{n22}{37.6}{38.9}{}}
	\xyshift{ 30mm}{-30mm}{\btreelnodethree{n23}{40.3}{41.5}{}}
	\xyshift{ 60mm}{-30mm}{\btreelnodethree{n24}{43.1}{47.1}{}}
	%
	% connecting intermediate level to leaf nodes
	\foreach \x in {1,2}     { \btreelink{n1-\x}{n1\x} }
	\foreach \x in {1,2,3,4} { \btreelink{n2-\x}{n2\x} }
	%
	% leaf pointers
	\draw[btlink] ([yshift=+3pt] n11-c.east) -- ([yshift=+3pt] n12-a.west);
	\draw[btlink] ([yshift=-3pt] n12-a.west) -- ([yshift=-3pt] n11-c.east);
	\draw[btlink] ([yshift=+3pt] n12-c.east) -- ([yshift=+3pt] n21-a.west);
	\draw[btlink] ([yshift=-3pt] n21-a.west) -- ([yshift=-3pt] n12-c.east);
	\draw[btlink] ([yshift=+3pt] n21-c.east) -- ([yshift=+3pt] n22-a.west);
	\draw[btlink] ([yshift=-3pt] n22-a.west) -- ([yshift=-3pt] n21-c.east);
	\draw[btlink] ([yshift=+3pt] n22-c.east) -- ([yshift=+3pt] n23-a.west);
	\draw[btlink] ([yshift=-3pt] n23-a.west) -- ([yshift=-3pt] n22-c.east);
	\draw[btlink] ([yshift=+3pt] n23-c.east) -- ([yshift=+3pt] n24-a.west);
	\draw[btlink] ([yshift=-3pt] n24-a.west) -- ([yshift=-3pt] n23-c.east);
	
	%
	
	\foreach \x in
	{n11-1,n11-2,n11-3,n12-1,n12-2,n21-1,n21-2,n22-1,n22-2, n23-1, n23-2, n24-1,n24-2}
	{ \path[<-] ([yshift=-15pt] \x.center) edge ([yshift=2pt] \x.center); }
	%
	
	
	
	\end{tikzpicture}
	\vspace{2mm}
	\caption{$B^+$tree after the insertion of $41.5$}
	\label{fig:insetionOf41}
\end{figure}




\subsection{Random Access: Lookup a Value}
Due to the properties of a circular array the lookup of a value at time $t$ is very efficient. Since the position can be directly calculated without looping through the array by using the interval between two consecutive measurements. The last update point can be used as reference time point for the calculation. The Lookup$(t)$ is presented in Algorithm \ref{alg:Lookup}.
%Lookup

\begin{algorithm}[H]
	\IncMargin{1em}
	\SetAlgoLined
	\DontPrintSemicolon
	\KwData{The circular array $array$ and the time point $t$}
	\KwResult{Returns the value $v$ at time point $t$}
	
	\Begin{
		   \If{array.count = 0}{
		   	//no values yet\;
		   	return NIL\;
		   }
		   
		   
		   step $\leftarrow$ ($t$ - array.data[array.lastUpdatePosition].time)\;
		   
		   \If{$|step|$ < array.count}{
		   	pos $\leftarrow$ 
		   	((array.lastUpdatePosition + step)\%array.size)\;
		   	
		   	\If{array.data[pos].time = t}{
		   		return array.data[pos].value\;
		   	}
		   }
		   
		   return NIL\;
	}	
	


	\caption{Lookup$(t)$}	
	\label{alg:Lookup}
\end{algorithm}


\begin{exmp}
	We assume we want to find the measurement value at time point $\text{14:10}$. The last update position was at time point $\text{14:20}$, thus the step is calculated as $-3$ and the position of time point $\text{14:10}$ is $0$.$2.5$ is returned by the Lookup Algorithm. The circular array is illustrated in Figure \ref{fig:circANow}.   
\end{exmp}


\begin{figure}[H]
	\centering
	\begin{tikzpicture}[
	scale=0.7,
	every node/.style={outer sep=0pt, transform shape, font=\scriptsize},
	every matrix/.style={cells={scale=0.7}},
	]
	
	\definecolor{mycolor}{RGB}{224,224,224}
	\definecolor{myorange}{RGB}{255,178,102}

	% circular array
	\xyshift{-15mm}{-100mm}{
		\matrix [ampersand replacement=\&, outer sep=0pt, matrix anchor=north] (array) {
			\node[circularptr,fill=myorange] (c1)  {2.5}; \&
			\node[circularptr] (c2)  {25.4}; \&
			\node[circularptr] (c3)  {3.0}; \&
			\node[circularptr,fill=mycolor](c4) {13.2}; \&
			\node[circularptr] (c5)  {23.0}; \&
			\node[circularptr] (c6)  {17.1}; \&
			\node[circularptr] (c7)  {37.6}; \&
			\node[circularptr] (c8)  {18.1}; \&
			\node[circularptr] (c9)  {7.2}; \&
			\node[circularptr] (c10) {25.4}; \&
			\node[circularptr] (c11) {38.9}; \&
			\node[circularptr] (c12) {47.1}; \&
			\node[circularptr] (c13) {43.1}; \&
			\node[circularptr] (c14) {40.3};  \\
			%
			\node[circularval,fill=myorange] (left) {14:10}; \&
			\node[circularval] {14:15}; \&
			\node[circularval] {14:20}; \&
			\node[circularval,fill=mycolor](right){14:25}; \&
			\node[circularval] {13:20}; \&
			\node[circularval] {13:25}; \&
			\node[circularval] {13:30}; \&
			\node[circularval] {13:35}; \&
			\node[circularval] {13:40}; \&
			\node[circularval] {13:45}; \&
			\node[circularval] {13:50}; \&
			\node[circularval] {13:55}; \&
			\node[circularval] {14:00}; \&
			\node[circularval] {14:05};\\
		};
	}
	
	% curly brace
	\draw [decorate,decoration={brace,mirror,amplitude=10pt}]
	([yshift=-5pt] left.south west) -- ([yshift=-5pt] right.south east)
	node [black,midway,yshift=-0.9cm] {3 steps};
		
	
	\end{tikzpicture}
	\vspace{2mm}
	\caption{$2.5$ is the value at time point $\text{14:10}$}
	\label{fig:circANow}
\end{figure}



\newpage
\subsection{Sorted Access: Neighbor}

\subsubsection{Initialize Neighborhood}

\lstset{language=C}
\begin{lstlisting}
struct {
  ListValue * timeStampPosition;
  Node * LeafPosition;
  int indexPosition;
} NeighborhoodPosition;

struct {
  int l;
  int j;
  double key;
  NeighborhoodPosition leftPosition;
  NeighborhoodPosition rightPosition;
} Neighborhood;
\end{lstlisting}
\BlankLine
\BlankLine



\begin{figure}[htbp]
	\centering
	\begin{tikzpicture}[
	scale=0.7,
	every node/.style={outer sep=0pt, transform shape, font=\scriptsize},
	every matrix/.style={cells={scale=0.7}},
	]
	
		\definecolor{myorange}{RGB}{255,178,102}
		\definecolor{myblue}{RGB}{51,153,255}
		\definecolor{myyellow}{RGB}{255,255,102}
		
		% circular array
		\xyshift{-15mm}{-100mm}{
			\matrix [ampersand replacement=\&, outer sep=0pt, matrix anchor=north] (array) {
				\node[circularptr, fill=myorange] (c1)  {37.6}; \&
				\node[circularptr, fill=myblue] (c2)  {25.4}; \&
				\node[circularptr, fill=myyellow] (c3)  {3.0}; \&
				\node[circularptr] (c4)  {13.2}; \&
				\node[circularptr] (c5)  {23.0}; \&
				\node[circularptr] (c6)  {17.1}; \&
				\node[circularptr] (c7)  {37.6}; \&
				\node[circularptr] (c8)  {18.1}; \&
				\node[circularptr] (c9)  {7.2}; \&
				\node[circularptr] (c10) {25.4}; \&
				\node[circularptr] (c11) {38.9}; \&
				\node[circularptr] (c12) {47.1}; \&
				\node[circularptr] (c13) {43.1}; \&
				\node[circularptr] (c14) {2.5};  \\
				%
				\node[circularval, fill=myorange] (left) {14:10}; \&
				\node[circularval, fill=myblue] {14:15}; \&
				\node[circularval, fill=myyellow] {14:20}; \&
				\node[circularval] {13:15}; \&
				\node[circularval] {13:20}; \&
				\node[circularval] {13:25}; \&
				\node[circularval] {13:30}; \&
				\node[circularval] {13:35}; \&
				\node[circularval] {13:40}; \&
				\node[circularval] {13:45}; \&
				\node[circularval] {13:50}; \&
				\node[circularval] {13:55}; \&
				\node[circularval] {14:00}; \&
				\node[circularval] (right){14:05};\\
			};
		}
	

	
	
	
	% root node
	\xyshift{-20mm}{0mm}{\btreeinodethree{root}{17.1}{}{}};
	
	%
	% intermediate nodes
	\xyshift{-50mm}{-15mm}{\btreeinodethree{n1}{7.2}{}{}{}}
	\xyshift{ 10mm}{-15mm}{\btreeinodethree{n2}{23.0}{37.6}{43.1}}
	%
	% connecting root to intermediate level nodes
	\foreach \x in {1,2} { \btreelink{root-\x}{n\x} }
	%
	% leaf nodes
	\xyshift{-90mm}{-30mm}{\btreelnodethree{n11}{2.5}{3.0}{}}
	\xyshift{-60mm}{-30mm}{\btreelnodethree{n12}{7.2}{13.2}{}}
	\xyshift{-30mm}{-30mm}{\btreelnodethree{n21}{17.1}{18.1}{}}
	\xyshift{ 0mm}{-30mm}{\btreelnodethree{n22}{23.0}{25.4}{}}
	\xyshift{ 30mm}{-30mm}{\btreelnodethree{n23}{37.6}{38.9}{}}
	\xyshift{ 60mm}{-30mm}{\btreelnodethree{n24}{43.1}{47.1}{}}
	%
	% connecting intermediate level to leaf nodes
	\foreach \x in {1,2}     { \btreelink{n1-\x}{n1\x} }
	\foreach \x in {1,2,3,4} { \btreelink{n2-\x}{n2\x} }
	%
	% leaf pointers
	\draw[btlink] ([yshift=+3pt] n11-c.east) -- ([yshift=+3pt] n12-a.west);
	\draw[btlink] ([yshift=-3pt] n12-a.west) -- ([yshift=-3pt] n11-c.east);
	\draw[btlink] ([yshift=+3pt] n12-c.east) -- ([yshift=+3pt] n21-a.west);
	\draw[btlink] ([yshift=-3pt] n21-a.west) -- ([yshift=-3pt] n12-c.east);
	\draw[btlink] ([yshift=+3pt] n21-c.east) -- ([yshift=+3pt] n22-a.west);
	\draw[btlink] ([yshift=-3pt] n22-a.west) -- ([yshift=-3pt] n21-c.east);
	\draw[btlink] ([yshift=+3pt] n22-c.east) -- ([yshift=+3pt] n23-a.west);
	\draw[btlink] ([yshift=-3pt] n23-a.west) -- ([yshift=-3pt] n22-c.east);
	\draw[btlink] ([yshift=+3pt] n23-c.east) -- ([yshift=+3pt] n24-a.west);
	\draw[btlink] ([yshift=-3pt] n24-a.west) -- ([yshift=-3pt] n23-c.east);
	%
	
	% circular array
	\xyshift{-40mm}{-60mm}{
		\matrix [ampersand replacement=\&, outer sep=0pt, matrix anchor=north] (array) {
			\node[circularptr] (c1)  {}; \\	
			%
			\node[circularval] (left)(right) {13:45}; \\
		};
	}
	% circular array
	\xyshift{-10mm}{-60mm}{
		\matrix [ampersand replacement=\&, outer sep=0pt, matrix anchor=north] (array) {
			\node[circularptr, fill=myblue] (c2)  {}; \\	
			%
			\node[circularval,fill=myblue] (left)(right) {14:15}; \\
		};
	}	
	
	
		% circular array
		\xyshift{20mm}{-60mm}{
			\matrix [ampersand replacement=\&, outer sep=0pt, matrix anchor=north] (array) {
				\node[circularptr] (c5)  {}; \\	
				%
				\node[circularval] (left)(right) {13:30}; \\
			};
		}
		% circular array
		\xyshift{50mm}{-60mm}{
			\matrix [ampersand replacement=\&, outer sep=0pt, matrix anchor=north] (array) {
				\node[circularptr, fill=myorange] (c6)  {}; \\	
				%
				\node[circularval,fill=myorange] (left)(right) {14:10}; \\
			};
		}	
		% draw pointers between circular array and B+ tree
		\path[btlink2] ([yshift=-2pt] c5.center)  edge[out=90,in=270] ([yshift=2pt] n23-1.center);
		% draw pointers for linked list
		\draw[btlink] ([yshift=-10pt] c5.east) -- ([yshift=-10pt] c6.west);
		\draw[btlink] ([yshift=-20pt] c6.west) -- ([yshift=-20pt] c5.east);
		
		%circular links
		\path[btlink] ([yshift=-10pt] c5.west)  edge[out=220,in=250] ([yshift=-10pt] c6.east);
		\path[btlink2] ([yshift=-20pt] c5.west)  edge[out=220,in=250] ([yshift=-20pt] c6.east);	
		
		
	
	% draw pointers between circular array and B+ tree
	\path[btlink2] ([yshift=-2pt] c1.center)  edge[out=90,in=270] ([yshift=2pt] n22-2.center);
	% draw pointers for linked list
	\draw[btlink] ([yshift=-10pt] c1.east) -- ([yshift=-10pt] c2.west);
	%\draw[btlink] ([yshift=-10pt] c2.east) -- ([yshift=-10pt] c1.east);
	\draw[btlink] ([yshift=-20pt] c2.west) -- ([yshift=-20pt] c1.east);
	
	%circular links
	\path[btlink] ([yshift=-10pt] c1.west)  edge[out=220,in=250] ([yshift=-10pt] c2.east);
	\path[btlink2] ([yshift=-20pt] c1.west)  edge[out=220,in=250] ([yshift=-20pt] c2.east);
	
	
	% list  value
	\xyshift{-90mm}{-50mm}{
		\matrix [ampersand replacement=\&, outer sep=0pt, matrix anchor=north] (array) {
			\node[circularptr] (c3)  {}; \\	
			%
			\node[circularval] (left)(right) {14:05}; \\
		};
	}
	
	% draw pointers between list value and B+ tree
	\path[btlink2] ([yshift=-2pt] c3.center)  edge[out=90,in=270] ([yshift=2pt] n11-1.center);
	
	%circular links
	\path[btlink] ([yshift=-16pt] c3.west)  edge[out=-1500,in=-60] ([yshift=-16pt] c3.east);
	\path[btlink2] ([yshift=-24pt] c3.west)  edge[out=-1500,in=-60] ([yshift=-24pt] c3.east);
	
	
	% list  value
	\xyshift{-70mm}{-50mm}{
		\matrix [ampersand replacement=\&, outer sep=0pt, matrix anchor=north] (array) {
			\node[circularptr,fill=myyellow] (c4)  {}; \\	
			%
			\node[circularval, fill=myyellow] (left)(right) {14:20}; \\
		};
	}
	
	% draw pointers between list value and B+ tree
	\path[btlink2] ([yshift=-2pt] c4.center)  edge[out=90,in=270] ([yshift=2pt] n11-2.center);
	
	%circular links
	\path[btlink] ([yshift=-16pt] c4.west)  edge[out=-1500,in=-60] ([yshift=-16pt] c4.east);
	\path[btlink2] ([yshift=-24pt] c4.west)  edge[out=-1500,in=-60] ([yshift=-24pt] c4.east);
	
	\foreach \x in
	{n12-1,n12-2,n21-1,n21-2,n22-1, n23-2, n23-3, n24-1,n24-2}
	{ \path[<-] ([yshift=-15pt] \x.center) edge ([yshift=2pt] \x.center); }
	%
	

	\end{tikzpicture}
	\vspace{2mm}
	\caption{Start situation}
	\label{fig:startSituation}
\end{figure}



/*
* Initializes a new neighborhood in the B+ tree.
*
* Parameters:
*   tree: The  SBTree for this neighborhood
*   Serie: Serie that constitutes this pattern cell
*   patternlength: length of the query pattern
*   offset: position of the Serie within the query pattern
*           cell. offset=1 means the oldest time point in the
*           query pattern, offset=patternlength means the latest
*           time point in the query pattern.
*/
%initialize Neighborhood


\begin{algorithm}[H]
	\IncMargin{1em}
	\SetAlgoLined
	\DontPrintSemicolon
	\KwData{Tree $tree$, the node $node$ and its neighbor $neighbor$, the neighborIndex $nIndex$, the $kIndex$ and the the key $kPrime$}
	\KwResult{The keys in the node and its neighbor, as well as the parents keys are redestributed}
	
	\Begin{
		    neighboorhood.key $\leftarrow$ measurement.value\;
		    neighboorhood.offset $\leftarrow$ offset\;
		    neighboorhood.patternLength $\leftarrow$ patternLength\;
		    
		    \BlankLine
		    leafNode $\leftarrow$ findLeaf(tree, measurement.value)\;
		    pointerIndex $\leftarrow$ getInsertionIndex(leafNode, measurement.value)\;
		    listValueOnThatKey $\leftarrow$ leafNode.pointers[pointerIndex]\;
		    \BlankLine
		    //Upper Bound: The value is at most patternLength away form first list value\;
		    maxSteps $\leftarrow$ patternLength\;
		    \While{listValueOnThatKey.timestamp $\neq$ measurement.timestamp \&\& maxSteps $\neq$ 0}{
		    	//go from newest value back towards oldest\;
		    	listValueOnThatKey $\leftarrow$ listValueOnThatKey.prev\;
		    	maxSteps--\;
		    }

		    neighboorhood.leftPosition $\leftarrow$ set position to $listValueOnThatKey$\;
		    neighboorhood.rightPosition $\leftarrow$ set position to $listValueOnThatKey$\;
		    \BlankLine
		    return neighboorhood;
	}	
	
	

	\caption{initializeNeighborhood}	\label{initializeNeighborhood}
\end{algorithm}

\subsubsection{Grow Neighborhood}
The \emph{neighborhood grow} is then executed $k$ times.

/*
* Grows the neighborhood by one new value and returns its time point via the time point
* parameter. The function returns true if there was a new unseen value and false otherwise
*
* Parameters
*   self: the neighborhood
*   timeset: a set of seen time points
*   time point: used as a return value, contains the time point of the
*              new still unseen value discovered by this function
*/
%neighborhod grow


\begin{algorithm}[H]
	\IncMargin{1em}
	\SetAlgoLined
	\DontPrintSemicolon
	\KwData{}
	\KwResult{}
	
	\Begin{
		    leftPos $\leftarrow$ self.leftPosition\;
		    rightPos $\leftarrow$ self.rightPosition\;


		    \While{$t^-$ $\neq$ NIL and TimeSetContains($t^-$ $-(j + l)$)}{
		    	
			    $leftPos^-$ $\leftarrow$ $leftPosition^-$ $- 1$\;
		    }
		    
		    \While{$t^-$ $\neq$ NIL and TimeSetContains($t^-$ $-(j + l)$)}{
		      	
		     	$rightPos^+$ $\leftarrow$ $rightPosition^+$ $+ 1$\;
		    }
		    
		   \If{$t^-$ $\neq$ NIL and  $t^+$ $\neq$ NIL }{
		   	\If{$|r_{i}(t^-)$ - self.key$|$ $\leq$ $|r_{i}(t^+)$ - self.key$|$}{
		   		
		   		$leftPos^-\leftarrow$ $leftPos^- - 1$\; $t$ $\leftarrow$ $t^-$\;
		 		
		   	}
		   	\Else{
		   		$rightPos^+\leftarrow$ $rightPos^+ + 1$\; $t$ $\leftarrow$ $t^+$\;
		   	}
		   	
		   	\uElseIf{$t^-$ $\neq$ NIL}{
		   		
		   		$leftPos^-\leftarrow$ $leftPos^- - 1$\; $t$ $\leftarrow$ $t^-$\;
		   	}
		   	\uElseIf{$t^+$ $\neq$ NIL}{
		   		$rightPos^+\leftarrow$ $rightPos^+ + 1$\; $t$ $\leftarrow$ $t^+$\;
		   		
		   	}
		   	\Else{
		   		return false\; 	
		   	}
		   }
	
		    return true\;
	}	
	
	

	\caption{NeighborhoodGrow}	\label{NeighborhoodGrow}
\end{algorithm}

\chapter{Complexity Analysis}

\subsection{Runtime Complexity}

\subsubsection{Circular Array Operations}
\paragraph{Update}
$O(1)$ 
\paragraph{Lookup}

\subsubsection{$B^+$tree Operations}
Although insertion and deletion operations on B+-trees are complicated, they are not very expensive.
In the worst case for an insertion is proportional to $\log_{n\setminus2}(|W|)$, where n is
the maximum number of pointers in a node, and K is the number of keys in the leaf nodes. If there are no duplicate values the number of keys is the size of the time window $|W|$. 
Since in our case the insertion point of a new measurement to a doubly, linked list is always found in $O(1)$, duplicates have no influence to the complexity of an insertion.  
\\The worst-case complexity of the deletion procedure is also proportional to
$\log_{n\setminus2}(|W|)$, even if there are duplicate values.


\subsubsection{Neighborhood Operations}

\paragraph{Neighborhood initialize}
The initialization of the neighborhood needs to search a specific measurement in the $B^+$tree. 
This is dependent on the number of values in the linked list associated to the key of the specific measurement. 
But the pattern length gives an upper bound to the maximum required value lookups in a doubly, linked list. In the worst-case the initialization needs to first find the appropriate leaf in $\log_{n\setminus2}(K)+patternlength$
\paragraph{Neighborhood grow}


\subsection{Space Complexity}
\subsubsection{Circular Array}

\subsubsection{$B^+$tree}

\chapter{Evaluation}
\label{sec:Experimental}

- runtime with different tree node sizes \\
- runtime with no duplicates\\
- runtime with duplicates\\
- increase size W\\
- 
- runtime neighborhood initialization - pattern length\\
- runtime neighborhood grow\\

memory und runtime evaluation:\\ 
nodesize, verteilung der daten \\
Datenset erstellen \\


\section{Experimental Setup}
\section{Results}
\section{Discussion}


\chapter{Related Works}


\chapter{Summary and Conclusion}
\label{sec:Summary}

+ wie macht man es effizient: bound erwähnen (neighborhood), leaves sortiert, neighborhood teuer. leaves sortiert ist gut, 
welche tree.nodesize


\begin{thebibliography}{99}
	\bibliographystyle{alpha}
	
	\bibitem{BScT} K. Wellenzohn, M. Böhlen, A. Dignos, J. Gamper, and H. Mitterer: \emph{Continuous imputation of missing values in highly correlated streams of time series data}; Unpublished, 2016.
	
	\bibitem{BTreeBook} Hector Garcia-Molina, Jeffrey D. Ullman, Jennifer Widom: \emph{Database Systems - The Complete Book}; ISBN 0-13-031995-3, 2002 by Prentice Hall
		
	\bibitem{DatabaseSystemC} Abraham Silberschatz, Henry F. Korth, S. Sudarshan: \emph{Database System Concepts}; ISBN 978-0-07-352332-3, 2011 by The McGraw-Hill Companies, Inc.

	\bibitem{LinkedListBook} Thomas H. Cormen, Charles E. Leiserson, Ronald L.Rivest, Clifford Stein: \emph{Introduction to Algorithms}; Massachusetts Institute of Technology, Massachusetts, USA, 2009. 


\end{thebibliography}






\end{document}
